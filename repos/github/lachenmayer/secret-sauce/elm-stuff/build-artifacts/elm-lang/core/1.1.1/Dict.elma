{"path":"","body":{"fixities":[],"aliases":{},"datatypes":{"LeafColor":[[],[["LBlack",[]],["LBBlack",[]]]],"Flag":[[],[["Insert",[]],["Remove",[]],["Same",[]]]],"Dict":[["k","v"],[["RBNode",[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]],["RBEmpty",[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"LeafColor"}}]]]],"NColor":[[],[["Red",[]],["Black",[]],["BBlack",[]],["NBlack",[]]]]},"types":{"blacken":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]},"max":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]},"Insert":{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Flag"}},"showFlag":{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Flag"}},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"String"}}]},"insert":{"tag":"Lambda","contents":[{"tag":"Var","contents":"comparable"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"v"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]}]}]},"Same":{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Flag"}},"moreBlack":{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}}]},"RBEmpty":{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"LeafColor"}},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]},"intersect":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]}]},"empty":{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},"BBlack":{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},"blackish":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]},"diff":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]}]},"values":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"v"}]]}]},"::":{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]}]},"showNColor":{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"String"}}]},"RBNode":{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},{"tag":"Lambda","contents":[{"tag":"Var","contents":"k"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"v"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]}]}]}]}]},"ensureBlackRoot":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]},"Red":{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},"foldr":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"comparable"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"v"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Var","contents":"b"}]}]}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"Var","contents":"b"}]}]}]},"union":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]}]},"balance":{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},{"tag":"Lambda","contents":[{"tag":"Var","contents":"k"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"v"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]}]}]}]}]},"bubble":{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},{"tag":"Lambda","contents":[{"tag":"Var","contents":"k"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"v"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]}]}]}]}]},"Remove":{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Flag"}},"get":{"tag":"Lambda","contents":[{"tag":"Var","contents":"comparable"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Maybe"]},"name":"Maybe"}},[{"tag":"Var","contents":"v"}]]}]}]},"remove":{"tag":"Lambda","contents":[{"tag":"Var","contents":"comparable"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]}]},"toList":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]]}]},"LBBlack":{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"LeafColor"}},"balance_node":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]},"NBlack":{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},"fromList":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]},"redden":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]},"keys":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"comparable"}]]}]},"map":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"comparable"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Var","contents":"b"}]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"b"}]]}]}]},"reportRemBug":{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"String"}},{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"String"}},{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"String"}},{"tag":"Var","contents":"a"}]}]}]}]},"singleton":{"tag":"Lambda","contents":[{"tag":"Var","contents":"comparable"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"v"},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]}]},"isBBlack":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]},"Black":{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},"rem":{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]}]}]},"partition":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"comparable"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"v"},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"}},[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]]}]}]},"showLColor":{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"LeafColor"}},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"String"}}]},"min":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]},"remove_max":{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},{"tag":"Lambda","contents":[{"tag":"Var","contents":"k"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"v"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]}]}]}]}]},"foldl":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"comparable"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"v"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Var","contents":"b"}]}]}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"Var","contents":"b"}]}]}]},"filter":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"comparable"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"v"},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]}]},"member":{"tag":"Lambda","contents":[{"tag":"Var","contents":"comparable"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]}]},"lessBlackTree":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]},"LBlack":{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"LeafColor"}},"lessBlack":{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}}]},"update":{"tag":"Lambda","contents":[{"tag":"Var","contents":"comparable"},{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Maybe"]},"name":"Maybe"}},[{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Maybe"]},"name":"Maybe"}},[{"tag":"Var","contents":"v"}]]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]}]}]}},"program":[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"foldr"},[{"tag":"Span","contents":[{"line":409,"column":5},{"line":417,"column":28},{"doc":"case t of\n  RBEmpty LBlack -> acc\n  RBNode _ key value left right -> foldr\n                                     f (f key value (foldr f acc right)) left"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"f"},[{"tag":"Span","contents":[{"line":409,"column":5},{"line":417,"column":28},{"doc":"case t of\n  RBEmpty LBlack -> acc\n  RBNode _ key value left right -> foldr\n                                     f (f key value (foldr f acc right)) left"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"acc"},[{"tag":"Span","contents":[{"line":409,"column":5},{"line":417,"column":28},{"doc":"case t of\n  RBEmpty LBlack -> acc\n  RBNode _ key value left right -> foldr\n                                     f (f key value (foldr f acc right)) left"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"t"},[{"tag":"Span","contents":[{"line":409,"column":5},{"line":417,"column":28},{"doc":"case t of\n  RBEmpty LBlack -> acc\n  RBNode _ key value left right -> foldr\n                                     f (f key value (foldr f acc right)) left"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":409,"column":10},{"line":409,"column":11},{"doc":"t"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"t"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBEmpty"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"LBlack"},[]]}]]},[{"tag":"Span","contents":[{"line":410,"column":25},{"line":410,"column":28},{"doc":"acc"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"acc"}}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Anything","contents":[]},{"tag":"Var","contents":"key"},{"tag":"Var","contents":"value"},{"tag":"Var","contents":"left"},{"tag":"Var","contents":"right"}]]},[{"tag":"Span","contents":[{"line":413,"column":11},{"line":413,"column":57},{"doc":"foldr f (f key value (foldr f acc right)) left"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":413,"column":11},{"line":413,"column":50},{"doc":"foldr f (f key value (foldr f acc right))"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":413,"column":11},{"line":413,"column":18},{"doc":"foldr f"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":413,"column":11},{"line":413,"column":16},{"doc":"foldr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"foldr"}}],[{"tag":"Span","contents":[{"line":413,"column":17},{"line":413,"column":18},{"doc":"f"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"f"}}]]}],[{"tag":"Span","contents":[{"line":413,"column":20},{"line":413,"column":50},{"doc":"f key value (foldr f acc right)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":413,"column":20},{"line":413,"column":31},{"doc":"f key value"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":413,"column":20},{"line":413,"column":25},{"doc":"f key"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":413,"column":20},{"line":413,"column":21},{"doc":"f"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"f"}}],[{"tag":"Span","contents":[{"line":413,"column":22},{"line":413,"column":25},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}]]}],[{"tag":"Span","contents":[{"line":413,"column":26},{"line":413,"column":31},{"doc":"value"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"value"}}]]}],[{"tag":"Span","contents":[{"line":413,"column":33},{"line":413,"column":50},{"doc":"foldr f acc right"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":413,"column":33},{"line":413,"column":44},{"doc":"foldr f acc"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":413,"column":33},{"line":413,"column":40},{"doc":"foldr f"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":413,"column":33},{"line":413,"column":38},{"doc":"foldr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"foldr"}}],[{"tag":"Span","contents":[{"line":413,"column":39},{"line":413,"column":40},{"doc":"f"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"f"}}]]}],[{"tag":"Span","contents":[{"line":413,"column":41},{"line":413,"column":44},{"doc":"acc"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"acc"}}]]}],[{"tag":"Span","contents":[{"line":413,"column":45},{"line":413,"column":50},{"doc":"right"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"right"}}]]}]]}]]}],[{"tag":"Span","contents":[{"line":413,"column":53},{"line":413,"column":57},{"doc":"left"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"left"}}]]}]]]]}]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"comparable"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"v"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Var","contents":"b"}]}]}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"Var","contents":"b"}]}]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"keys"},[{"tag":"Span","contents":[{"line":440,"column":5},{"line":440,"column":57},{"doc":"foldr (\\key value keyList -> key :: keyList) [] dict"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"dict"},[{"tag":"Span","contents":[{"line":440,"column":5},{"line":440,"column":57},{"doc":"foldr (\\key value keyList -> key :: keyList) [] dict"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":440,"column":5},{"line":440,"column":52},{"doc":"foldr (\\key value keyList -> key :: keyList) []"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":440,"column":5},{"line":440,"column":48},{"doc":"foldr (\\key value keyList -> key :: keyList)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":440,"column":5},{"line":440,"column":10},{"doc":"foldr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"foldr"}}],[{"tag":"Span","contents":[{"line":440,"column":34},{"line":440,"column":48},{"doc":"key :: keyList"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"key"},[{"tag":"Span","contents":[{"line":440,"column":34},{"line":440,"column":48},{"doc":"key :: keyList"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"value"},[{"tag":"Span","contents":[{"line":440,"column":34},{"line":440,"column":48},{"doc":"key :: keyList"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"keyList"},[{"tag":"Span","contents":[{"line":440,"column":34},{"line":440,"column":48},{"doc":"key :: keyList"}]},{"tag":"Binop","contents":[{"home":{"tag":"Module","contents":["List"]},"name":"::"},[{"tag":"Span","contents":[{"line":440,"column":34},{"line":440,"column":37},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}],[{"tag":"Span","contents":[{"line":440,"column":41},{"line":440,"column":48},{"doc":"keyList"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"keyList"}}]]}]]}]]}]]}]]}],[{"tag":"Span","contents":[{"line":440,"column":50},{"line":440,"column":52},{"doc":"[]"}]},{"tag":"ExplicitList","contents":[]}]]}],[{"tag":"Span","contents":[{"line":440,"column":53},{"line":440,"column":57},{"doc":"dict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"dict"}}]]}]]}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"comparable"}]]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"values"},[{"tag":"Span","contents":[{"line":446,"column":5},{"line":446,"column":63},{"doc":"foldr (\\key value valueList -> value :: valueList) [] dict"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"dict"},[{"tag":"Span","contents":[{"line":446,"column":5},{"line":446,"column":63},{"doc":"foldr (\\key value valueList -> value :: valueList) [] dict"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":446,"column":5},{"line":446,"column":58},{"doc":"foldr (\\key value valueList -> value :: valueList) []"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":446,"column":5},{"line":446,"column":54},{"doc":"foldr (\\key value valueList -> value :: valueList)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":446,"column":5},{"line":446,"column":10},{"doc":"foldr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"foldr"}}],[{"tag":"Span","contents":[{"line":446,"column":36},{"line":446,"column":54},{"doc":"value :: valueList"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"key"},[{"tag":"Span","contents":[{"line":446,"column":36},{"line":446,"column":54},{"doc":"value :: valueList"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"value"},[{"tag":"Span","contents":[{"line":446,"column":36},{"line":446,"column":54},{"doc":"value :: valueList"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"valueList"},[{"tag":"Span","contents":[{"line":446,"column":36},{"line":446,"column":54},{"doc":"value :: valueList"}]},{"tag":"Binop","contents":[{"home":{"tag":"Module","contents":["List"]},"name":"::"},[{"tag":"Span","contents":[{"line":446,"column":36},{"line":446,"column":41},{"doc":"value"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"value"}}],[{"tag":"Span","contents":[{"line":446,"column":45},{"line":446,"column":54},{"doc":"valueList"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"valueList"}}]]}]]}]]}]]}]]}],[{"tag":"Span","contents":[{"line":446,"column":56},{"line":446,"column":58},{"doc":"[]"}]},{"tag":"ExplicitList","contents":[]}]]}],[{"tag":"Span","contents":[{"line":446,"column":59},{"line":446,"column":63},{"doc":"dict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"dict"}}]]}]]}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"v"}]]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"toList"},[{"tag":"Span","contents":[{"line":452,"column":5},{"line":452,"column":59},{"doc":"foldr (\\key value list -> (key,value) :: list) [] dict"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"dict"},[{"tag":"Span","contents":[{"line":452,"column":5},{"line":452,"column":59},{"doc":"foldr (\\key value list -> (key,value) :: list) [] dict"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":452,"column":5},{"line":452,"column":54},{"doc":"foldr (\\key value list -> (key,value) :: list) []"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":452,"column":5},{"line":452,"column":50},{"doc":"foldr (\\key value list -> (key,value) :: list)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":452,"column":5},{"line":452,"column":10},{"doc":"foldr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"foldr"}}],[{"tag":"Span","contents":[{"line":452,"column":32},{"line":452,"column":50},{"doc":"(key,value) :: list"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"key"},[{"tag":"Span","contents":[{"line":452,"column":32},{"line":452,"column":50},{"doc":"(key,value) :: list"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"value"},[{"tag":"Span","contents":[{"line":452,"column":32},{"line":452,"column":50},{"doc":"(key,value) :: list"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"list"},[{"tag":"Span","contents":[{"line":452,"column":32},{"line":452,"column":50},{"doc":"(key,value) :: list"}]},{"tag":"Binop","contents":[{"home":{"tag":"Module","contents":["List"]},"name":"::"},[{"tag":"Span","contents":[{"line":452,"column":32},{"line":452,"column":41},{"doc":"(key,value)"}]},{"tag":"Data","contents":["_Tuple2",[[{"tag":"Span","contents":[{"line":452,"column":32},{"line":452,"column":35},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}],[{"tag":"Span","contents":[{"line":452,"column":36},{"line":452,"column":41},{"doc":"value"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"value"}}]]]}],[{"tag":"Span","contents":[{"line":452,"column":46},{"line":452,"column":50},{"doc":"list"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"list"}}]]}]]}]]}]]}]]}],[{"tag":"Span","contents":[{"line":452,"column":52},{"line":452,"column":54},{"doc":"[]"}]},{"tag":"ExplicitList","contents":[]}]]}],[{"tag":"Span","contents":[{"line":452,"column":55},{"line":452,"column":59},{"doc":"dict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"dict"}}]]}]]}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"foldl"},[{"tag":"Span","contents":[{"line":398,"column":5},{"line":406,"column":22},{"doc":"case dict of\n  RBEmpty LBlack -> acc\n  RBNode _ key value left right -> foldl\n                                     f (f key value (foldl f acc left)) right"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"f"},[{"tag":"Span","contents":[{"line":398,"column":5},{"line":406,"column":22},{"doc":"case dict of\n  RBEmpty LBlack -> acc\n  RBNode _ key value left right -> foldl\n                                     f (f key value (foldl f acc left)) right"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"acc"},[{"tag":"Span","contents":[{"line":398,"column":5},{"line":406,"column":22},{"doc":"case dict of\n  RBEmpty LBlack -> acc\n  RBNode _ key value left right -> foldl\n                                     f (f key value (foldl f acc left)) right"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"dict"},[{"tag":"Span","contents":[{"line":398,"column":5},{"line":406,"column":22},{"doc":"case dict of\n  RBEmpty LBlack -> acc\n  RBNode _ key value left right -> foldl\n                                     f (f key value (foldl f acc left)) right"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":398,"column":10},{"line":398,"column":14},{"doc":"dict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"dict"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBEmpty"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"LBlack"},[]]}]]},[{"tag":"Span","contents":[{"line":399,"column":25},{"line":399,"column":28},{"doc":"acc"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"acc"}}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Anything","contents":[]},{"tag":"Var","contents":"key"},{"tag":"Var","contents":"value"},{"tag":"Var","contents":"left"},{"tag":"Var","contents":"right"}]]},[{"tag":"Span","contents":[{"line":402,"column":11},{"line":402,"column":57},{"doc":"foldl f (f key value (foldl f acc left)) right"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":402,"column":11},{"line":402,"column":49},{"doc":"foldl f (f key value (foldl f acc left))"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":402,"column":11},{"line":402,"column":18},{"doc":"foldl f"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":402,"column":11},{"line":402,"column":16},{"doc":"foldl"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"foldl"}}],[{"tag":"Span","contents":[{"line":402,"column":17},{"line":402,"column":18},{"doc":"f"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"f"}}]]}],[{"tag":"Span","contents":[{"line":402,"column":20},{"line":402,"column":49},{"doc":"f key value (foldl f acc left)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":402,"column":20},{"line":402,"column":31},{"doc":"f key value"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":402,"column":20},{"line":402,"column":25},{"doc":"f key"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":402,"column":20},{"line":402,"column":21},{"doc":"f"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"f"}}],[{"tag":"Span","contents":[{"line":402,"column":22},{"line":402,"column":25},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}]]}],[{"tag":"Span","contents":[{"line":402,"column":26},{"line":402,"column":31},{"doc":"value"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"value"}}]]}],[{"tag":"Span","contents":[{"line":402,"column":33},{"line":402,"column":49},{"doc":"foldl f acc left"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":402,"column":33},{"line":402,"column":44},{"doc":"foldl f acc"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":402,"column":33},{"line":402,"column":40},{"doc":"foldl f"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":402,"column":33},{"line":402,"column":38},{"doc":"foldl"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"foldl"}}],[{"tag":"Span","contents":[{"line":402,"column":39},{"line":402,"column":40},{"doc":"f"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"f"}}]]}],[{"tag":"Span","contents":[{"line":402,"column":41},{"line":402,"column":44},{"doc":"acc"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"acc"}}]]}],[{"tag":"Span","contents":[{"line":402,"column":45},{"line":402,"column":49},{"doc":"left"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"left"}}]]}]]}]]}],[{"tag":"Span","contents":[{"line":402,"column":52},{"line":402,"column":57},{"doc":"right"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"right"}}]]}]]]]}]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"comparable"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"v"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Var","contents":"b"}]}]}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"Var","contents":"b"}]}]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"isBBlack"},[{"tag":"Span","contents":[{"line":228,"column":5},{"line":231,"column":17},{"doc":"case dict of\n  RBNode BBlack _ _ _ _ -> True\n  RBEmpty LBBlack -> True\n  _ -> False"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"dict"},[{"tag":"Span","contents":[{"line":228,"column":5},{"line":231,"column":17},{"doc":"case dict of\n  RBNode BBlack _ _ _ _ -> True\n  RBEmpty LBBlack -> True\n  _ -> False"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":228,"column":10},{"line":228,"column":14},{"doc":"dict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"dict"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"BBlack"},[]]},{"tag":"Anything","contents":[]},{"tag":"Anything","contents":[]},{"tag":"Anything","contents":[]},{"tag":"Anything","contents":[]}]]},[{"tag":"Span","contents":[{"line":229,"column":32},{"line":229,"column":36},{"doc":"True"}]},{"tag":"Literal","contents":{"tag":"Boolean","contents":true}}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBEmpty"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"LBBlack"},[]]}]]},[{"tag":"Span","contents":[{"line":230,"column":26},{"line":230,"column":30},{"doc":"True"}]},{"tag":"Literal","contents":{"tag":"Boolean","contents":true}}]],[{"tag":"Anything","contents":[]},[{"tag":"Span","contents":[{"line":231,"column":12},{"line":231,"column":17},{"doc":"False"}]},{"tag":"Literal","contents":{"tag":"Boolean","contents":false}}]]]]}]]}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"showFlag"},[{"tag":"Span","contents":[{"line":174,"column":14},{"line":180,"column":82},{"doc":"case f of\n  Insert -> \"Insert\"\n  Remove -> \"Remove\"\n  Same -> \"Same\""}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"f"},[{"tag":"Span","contents":[{"line":174,"column":14},{"line":180,"column":82},{"doc":"case f of\n  Insert -> \"Insert\"\n  Remove -> \"Remove\"\n  Same -> \"Same\""}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":174,"column":19},{"line":174,"column":20},{"doc":"f"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"f"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Insert"},[]]},[{"tag":"Span","contents":[{"line":175,"column":13},{"line":175,"column":21},{"doc":"\"Insert\""}]},{"tag":"Literal","contents":{"tag":"Str","contents":"Insert"}}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Remove"},[]]},[{"tag":"Span","contents":[{"line":176,"column":13},{"line":176,"column":21},{"doc":"\"Remove\""}]},{"tag":"Literal","contents":{"tag":"Str","contents":"Remove"}}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Same"},[]]},[{"tag":"Span","contents":[{"line":177,"column":13},{"line":177,"column":19},{"doc":"\"Same\""}]},{"tag":"Literal","contents":{"tag":"Str","contents":"Same"}}]]]]}]]}],{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Flag"}},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"String"}}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"Same"},[{"tag":"None","contents":{"doc":"Same"}},{"tag":"Data","contents":["Same",[]]}],{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Flag"}},[]]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"Remove"},[{"tag":"None","contents":{"doc":"Remove"}},{"tag":"Data","contents":["Remove",[]]}],{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Flag"}},[]]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"Insert"},[{"tag":"None","contents":{"doc":"Insert"}},{"tag":"Data","contents":["Insert",[]]}],{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Flag"}},[]]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"get"},[{"tag":"Span","contents":[{"line":125,"column":5},{"line":136,"column":46},{"doc":"case dict of\n  RBEmpty LBlack -> Nothing\n  RBNode _ key value left right -> case compare targetKey key of\n                                     LT -> get targetKey left\n                                     EQ -> Just value\n                                     GT -> get targetKey right"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"targetKey"},[{"tag":"Span","contents":[{"line":125,"column":5},{"line":136,"column":46},{"doc":"case dict of\n  RBEmpty LBlack -> Nothing\n  RBNode _ key value left right -> case compare targetKey key of\n                                     LT -> get targetKey left\n                                     EQ -> Just value\n                                     GT -> get targetKey right"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"dict"},[{"tag":"Span","contents":[{"line":125,"column":5},{"line":136,"column":46},{"doc":"case dict of\n  RBEmpty LBlack -> Nothing\n  RBNode _ key value left right -> case compare targetKey key of\n                                     LT -> get targetKey left\n                                     EQ -> Just value\n                                     GT -> get targetKey right"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":125,"column":10},{"line":125,"column":14},{"doc":"dict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"dict"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBEmpty"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"LBlack"},[]]}]]},[{"tag":"Span","contents":[{"line":127,"column":11},{"line":127,"column":18},{"doc":"Nothing"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Maybe"]},"name":"Nothing"}}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Anything","contents":[]},{"tag":"Var","contents":"key"},{"tag":"Var","contents":"value"},{"tag":"Var","contents":"left"},{"tag":"Var","contents":"right"}]]},[{"tag":"Span","contents":[{"line":130,"column":11},{"line":136,"column":46},{"doc":"case compare targetKey key of\n  LT -> get targetKey left\n  EQ -> Just value\n  GT -> get targetKey right"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":130,"column":16},{"line":130,"column":37},{"doc":"compare targetKey key"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":130,"column":16},{"line":130,"column":33},{"doc":"compare targetKey"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":130,"column":16},{"line":130,"column":23},{"doc":"compare"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Basics"]},"name":"compare"}}],[{"tag":"Span","contents":[{"line":130,"column":24},{"line":130,"column":33},{"doc":"targetKey"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"targetKey"}}]]}],[{"tag":"Span","contents":[{"line":130,"column":34},{"line":130,"column":37},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}]]}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Basics"]},"name":"LT"},[]]},[{"tag":"Span","contents":[{"line":131,"column":19},{"line":131,"column":37},{"doc":"get targetKey left"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":131,"column":19},{"line":131,"column":32},{"doc":"get targetKey"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":131,"column":19},{"line":131,"column":22},{"doc":"get"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"get"}}],[{"tag":"Span","contents":[{"line":131,"column":23},{"line":131,"column":32},{"doc":"targetKey"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"targetKey"}}]]}],[{"tag":"Span","contents":[{"line":131,"column":33},{"line":131,"column":37},{"doc":"left"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"left"}}]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Basics"]},"name":"EQ"},[]]},[{"tag":"Span","contents":[{"line":132,"column":19},{"line":132,"column":29},{"doc":"Just value"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":132,"column":19},{"line":132,"column":23},{"doc":"Just"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Maybe"]},"name":"Just"}}],[{"tag":"Span","contents":[{"line":132,"column":24},{"line":132,"column":29},{"doc":"value"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"value"}}]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Basics"]},"name":"GT"},[]]},[{"tag":"Span","contents":[{"line":133,"column":19},{"line":133,"column":38},{"doc":"get targetKey right"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":133,"column":19},{"line":133,"column":32},{"doc":"get targetKey"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":133,"column":19},{"line":133,"column":22},{"doc":"get"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"get"}}],[{"tag":"Span","contents":[{"line":133,"column":23},{"line":133,"column":32},{"doc":"targetKey"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"targetKey"}}]]}],[{"tag":"Span","contents":[{"line":133,"column":33},{"line":133,"column":38},{"doc":"right"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"right"}}]]}]]]]}]]]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"Var","contents":"comparable"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Maybe"]},"name":"Maybe"}},[{"tag":"Var","contents":"v"}]]}]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"member"},[{"tag":"Span","contents":[{"line":139,"column":5},{"line":141,"column":23},{"doc":"case get key dict of\n  Just _ -> True\n  Nothing -> False"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"key"},[{"tag":"Span","contents":[{"line":139,"column":5},{"line":141,"column":23},{"doc":"case get key dict of\n  Just _ -> True\n  Nothing -> False"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"dict"},[{"tag":"Span","contents":[{"line":139,"column":5},{"line":141,"column":23},{"doc":"case get key dict of\n  Just _ -> True\n  Nothing -> False"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":139,"column":10},{"line":139,"column":22},{"doc":"get key dict"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":139,"column":10},{"line":139,"column":17},{"doc":"get key"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":139,"column":10},{"line":139,"column":13},{"doc":"get"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"get"}}],[{"tag":"Span","contents":[{"line":139,"column":14},{"line":139,"column":17},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}]]}],[{"tag":"Span","contents":[{"line":139,"column":18},{"line":139,"column":22},{"doc":"dict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"dict"}}]]}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Maybe"]},"name":"Just"},[{"tag":"Anything","contents":[]}]]},[{"tag":"Span","contents":[{"line":140,"column":17},{"line":140,"column":21},{"doc":"True"}]},{"tag":"Literal","contents":{"tag":"Boolean","contents":true}}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Maybe"]},"name":"Nothing"},[]]},[{"tag":"Span","contents":[{"line":141,"column":18},{"line":141,"column":23},{"doc":"False"}]},{"tag":"Literal","contents":{"tag":"Boolean","contents":false}}]]]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"Var","contents":"comparable"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"max"},[{"tag":"Span","contents":[{"line":101,"column":5},{"line":122,"column":3},{"doc":"case dict of\n  RBNode _ key value _ (RBEmpty _) -> (key,value)\n  RBNode _ _ _ _ right -> max right\n  RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\""}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"dict"},[{"tag":"Span","contents":[{"line":101,"column":5},{"line":122,"column":3},{"doc":"case dict of\n  RBNode _ key value _ (RBEmpty _) -> (key,value)\n  RBNode _ _ _ _ right -> max right\n  RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\""}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":101,"column":10},{"line":101,"column":14},{"doc":"dict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"dict"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Anything","contents":[]},{"tag":"Var","contents":"key"},{"tag":"Var","contents":"value"},{"tag":"Anything","contents":[]},{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBEmpty"},[{"tag":"Anything","contents":[]}]]}]]},[{"tag":"Span","contents":[{"line":103,"column":12},{"line":103,"column":22},{"doc":"(key,value)"}]},{"tag":"Data","contents":["_Tuple2",[[{"tag":"Span","contents":[{"line":103,"column":12},{"line":103,"column":15},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}],[{"tag":"Span","contents":[{"line":103,"column":17},{"line":103,"column":22},{"doc":"value"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"value"}}]]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Anything","contents":[]},{"tag":"Anything","contents":[]},{"tag":"Anything","contents":[]},{"tag":"Anything","contents":[]},{"tag":"Var","contents":"right"}]]},[{"tag":"Span","contents":[{"line":106,"column":11},{"line":106,"column":20},{"doc":"max right"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":106,"column":11},{"line":106,"column":14},{"doc":"max"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"max"}}],[{"tag":"Span","contents":[{"line":106,"column":15},{"line":106,"column":20},{"doc":"right"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"right"}}]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBEmpty"},[{"tag":"Anything","contents":[]}]]},[{"tag":"Span","contents":[{"line":109,"column":18},{"line":109,"column":58},{"doc":"Native.Debug.crash \"(max Empty) is not defined\""}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":109,"column":18},{"line":109,"column":29},{"doc":"Native.Debug.crash"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","Debug"]},"name":"crash"}}],[{"tag":"Span","contents":[{"line":109,"column":30},{"line":109,"column":58},{"doc":"\"(max Empty) is not defined\""}]},{"tag":"Literal","contents":{"tag":"Str","contents":"(max Empty) is not defined"}}]]}]]]]}]]}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"min"},[{"tag":"Span","contents":[{"line":88,"column":5},{"line":96,"column":58},{"doc":"case dict of\n  RBNode _ key value (RBEmpty LBlack) _ -> (key,value)\n  RBNode _ _ _ left _ -> min left\n  RBEmpty LBlack -> Native.Debug.crash \"(min Empty) is not defined\""}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"dict"},[{"tag":"Span","contents":[{"line":88,"column":5},{"line":96,"column":58},{"doc":"case dict of\n  RBNode _ key value (RBEmpty LBlack) _ -> (key,value)\n  RBNode _ _ _ left _ -> min left\n  RBEmpty LBlack -> Native.Debug.crash \"(min Empty) is not defined\""}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":88,"column":10},{"line":88,"column":14},{"doc":"dict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"dict"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Anything","contents":[]},{"tag":"Var","contents":"key"},{"tag":"Var","contents":"value"},{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBEmpty"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"LBlack"},[]]}]]},{"tag":"Anything","contents":[]}]]},[{"tag":"Span","contents":[{"line":90,"column":12},{"line":90,"column":22},{"doc":"(key,value)"}]},{"tag":"Data","contents":["_Tuple2",[[{"tag":"Span","contents":[{"line":90,"column":12},{"line":90,"column":15},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}],[{"tag":"Span","contents":[{"line":90,"column":17},{"line":90,"column":22},{"doc":"value"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"value"}}]]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Anything","contents":[]},{"tag":"Anything","contents":[]},{"tag":"Anything","contents":[]},{"tag":"Var","contents":"left"},{"tag":"Anything","contents":[]}]]},[{"tag":"Span","contents":[{"line":93,"column":11},{"line":93,"column":19},{"doc":"min left"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":93,"column":11},{"line":93,"column":14},{"doc":"min"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"min"}}],[{"tag":"Span","contents":[{"line":93,"column":15},{"line":93,"column":19},{"doc":"left"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"left"}}]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBEmpty"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"LBlack"},[]]}]]},[{"tag":"Span","contents":[{"line":96,"column":18},{"line":96,"column":58},{"doc":"Native.Debug.crash \"(min Empty) is not defined\""}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":96,"column":18},{"line":96,"column":29},{"doc":"Native.Debug.crash"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","Debug"]},"name":"crash"}}],[{"tag":"Span","contents":[{"line":96,"column":30},{"line":96,"column":58},{"doc":"\"(min Empty) is not defined\""}]},{"tag":"Literal","contents":{"tag":"Str","contents":"(min Empty) is not defined"}}]]}]]]]}]]}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"RBEmpty"},[{"tag":"None","contents":{"doc":"RBEmpty a"}},{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},[{"tag":"None","contents":{"doc":"RBEmpty a"}},{"tag":"Data","contents":["RBEmpty",[[{"tag":"None","contents":{"doc":"a"}},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"a"}}]]]}]]}],{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"LeafColor"}},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"RBNode"},[{"tag":"None","contents":{"doc":"RBNode a b c d e"}},{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},[{"tag":"None","contents":{"doc":"RBNode a b c d e"}},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},[{"tag":"None","contents":{"doc":"RBNode a b c d e"}},{"tag":"Lambda","contents":[{"tag":"Var","contents":"c"},[{"tag":"None","contents":{"doc":"RBNode a b c d e"}},{"tag":"Lambda","contents":[{"tag":"Var","contents":"d"},[{"tag":"None","contents":{"doc":"RBNode a b c d e"}},{"tag":"Lambda","contents":[{"tag":"Var","contents":"e"},[{"tag":"None","contents":{"doc":"RBNode a b c d e"}},{"tag":"Data","contents":["RBNode",[[{"tag":"None","contents":{"doc":"a"}},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"a"}}],[{"tag":"None","contents":{"doc":"b"}},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"b"}}],[{"tag":"None","contents":{"doc":"c"}},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"c"}}],[{"tag":"None","contents":{"doc":"d"}},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"d"}}],[{"tag":"None","contents":{"doc":"e"}},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"e"}}]]]}]]}]]}]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},{"tag":"Lambda","contents":[{"tag":"Var","contents":"k"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"v"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]}]}]}]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"showLColor"},[{"tag":"Span","contents":[{"line":71,"column":5},{"line":73,"column":27},{"doc":"case color of\n  LBlack -> \"LBlack\"\n  LBBlack -> \"LBBlack\""}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"color"},[{"tag":"Span","contents":[{"line":71,"column":5},{"line":73,"column":27},{"doc":"case color of\n  LBlack -> \"LBlack\"\n  LBBlack -> \"LBBlack\""}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":71,"column":10},{"line":71,"column":15},{"doc":"color"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"color"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"LBlack"},[]]},[{"tag":"Span","contents":[{"line":72,"column":18},{"line":72,"column":26},{"doc":"\"LBlack\""}]},{"tag":"Literal","contents":{"tag":"Str","contents":"LBlack"}}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"LBBlack"},[]]},[{"tag":"Span","contents":[{"line":73,"column":18},{"line":73,"column":27},{"doc":"\"LBBlack\""}]},{"tag":"Literal","contents":{"tag":"Str","contents":"LBBlack"}}]]]]}]]}],{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"LeafColor"}},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"String"}}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"LBBlack"},[{"tag":"None","contents":{"doc":"LBBlack"}},{"tag":"Data","contents":["LBBlack",[]]}],{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"LeafColor"}},[]]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"LBlack"},[{"tag":"None","contents":{"doc":"LBlack"}},{"tag":"Data","contents":["LBlack",[]]}],{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"LeafColor"}},[]]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"empty"},[{"tag":"Span","contents":[{"line":83,"column":9},{"line":83,"column":23},{"doc":"RBEmpty LBlack"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":83,"column":9},{"line":83,"column":16},{"doc":"RBEmpty"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBEmpty"}}],[{"tag":"Span","contents":[{"line":83,"column":17},{"line":83,"column":23},{"doc":"LBlack"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"LBlack"}}]]}],{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"map"},[{"tag":"Span","contents":[{"line":386,"column":5},{"line":395,"column":23},{"doc":"case dict of\n  RBEmpty LBlack -> RBEmpty LBlack\n  RBNode clr key value left right -> RBNode\n                                       clr key (f key value) (map f left) (map f right)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"f"},[{"tag":"Span","contents":[{"line":386,"column":5},{"line":395,"column":23},{"doc":"case dict of\n  RBEmpty LBlack -> RBEmpty LBlack\n  RBNode clr key value left right -> RBNode\n                                       clr key (f key value) (map f left) (map f right)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"dict"},[{"tag":"Span","contents":[{"line":386,"column":5},{"line":395,"column":23},{"doc":"case dict of\n  RBEmpty LBlack -> RBEmpty LBlack\n  RBNode clr key value left right -> RBNode\n                                       clr key (f key value) (map f left) (map f right)"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":386,"column":10},{"line":386,"column":14},{"doc":"dict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"dict"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBEmpty"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"LBlack"},[]]}]]},[{"tag":"Span","contents":[{"line":388,"column":11},{"line":388,"column":25},{"doc":"RBEmpty LBlack"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":388,"column":11},{"line":388,"column":18},{"doc":"RBEmpty"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBEmpty"}}],[{"tag":"Span","contents":[{"line":388,"column":19},{"line":388,"column":25},{"doc":"LBlack"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"LBlack"}}]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Var","contents":"clr"},{"tag":"Var","contents":"key"},{"tag":"Var","contents":"value"},{"tag":"Var","contents":"left"},{"tag":"Var","contents":"right"}]]},[{"tag":"Span","contents":[{"line":391,"column":11},{"line":391,"column":65},{"doc":"RBNode clr key (f key value) (map f left) (map f right)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":391,"column":11},{"line":391,"column":51},{"doc":"RBNode clr key (f key value) (map f left)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":391,"column":11},{"line":391,"column":38},{"doc":"RBNode clr key (f key value)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":391,"column":11},{"line":391,"column":25},{"doc":"RBNode clr key"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":391,"column":11},{"line":391,"column":21},{"doc":"RBNode clr"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":391,"column":11},{"line":391,"column":17},{"doc":"RBNode"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBNode"}}],[{"tag":"Span","contents":[{"line":391,"column":18},{"line":391,"column":21},{"doc":"clr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"clr"}}]]}],[{"tag":"Span","contents":[{"line":391,"column":22},{"line":391,"column":25},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}]]}],[{"tag":"Span","contents":[{"line":391,"column":27},{"line":391,"column":38},{"doc":"f key value"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":391,"column":27},{"line":391,"column":32},{"doc":"f key"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":391,"column":27},{"line":391,"column":28},{"doc":"f"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"f"}}],[{"tag":"Span","contents":[{"line":391,"column":29},{"line":391,"column":32},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}]]}],[{"tag":"Span","contents":[{"line":391,"column":33},{"line":391,"column":38},{"doc":"value"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"value"}}]]}]]}],[{"tag":"Span","contents":[{"line":391,"column":41},{"line":391,"column":51},{"doc":"map f left"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":391,"column":41},{"line":391,"column":46},{"doc":"map f"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":391,"column":41},{"line":391,"column":44},{"doc":"map"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"map"}}],[{"tag":"Span","contents":[{"line":391,"column":45},{"line":391,"column":46},{"doc":"f"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"f"}}]]}],[{"tag":"Span","contents":[{"line":391,"column":47},{"line":391,"column":51},{"doc":"left"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"left"}}]]}]]}],[{"tag":"Span","contents":[{"line":391,"column":54},{"line":391,"column":65},{"doc":"map f right"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":391,"column":54},{"line":391,"column":59},{"doc":"map f"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":391,"column":54},{"line":391,"column":57},{"doc":"map"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"map"}}],[{"tag":"Span","contents":[{"line":391,"column":58},{"line":391,"column":59},{"doc":"f"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"f"}}]]}],[{"tag":"Span","contents":[{"line":391,"column":60},{"line":391,"column":65},{"doc":"right"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"right"}}]]}]]}]]]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"comparable"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Var","contents":"b"}]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"b"}]]}]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"showNColor"},[{"tag":"Span","contents":[{"line":57,"column":3},{"line":61,"column":23},{"doc":"case c of\n  Red -> \"Red\"\n  Black -> \"Black\"\n  BBlack -> \"BBlack\"\n  NBlack -> \"NBlack\""}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"c"},[{"tag":"Span","contents":[{"line":57,"column":3},{"line":61,"column":23},{"doc":"case c of\n  Red -> \"Red\"\n  Black -> \"Black\"\n  BBlack -> \"BBlack\"\n  NBlack -> \"NBlack\""}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":57,"column":8},{"line":57,"column":9},{"doc":"c"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"c"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Red"},[]]},[{"tag":"Span","contents":[{"line":58,"column":15},{"line":58,"column":20},{"doc":"\"Red\""}]},{"tag":"Literal","contents":{"tag":"Str","contents":"Red"}}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Black"},[]]},[{"tag":"Span","contents":[{"line":59,"column":15},{"line":59,"column":22},{"doc":"\"Black\""}]},{"tag":"Literal","contents":{"tag":"Str","contents":"Black"}}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"BBlack"},[]]},[{"tag":"Span","contents":[{"line":60,"column":15},{"line":60,"column":23},{"doc":"\"BBlack\""}]},{"tag":"Literal","contents":{"tag":"Str","contents":"BBlack"}}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"NBlack"},[]]},[{"tag":"Span","contents":[{"line":61,"column":15},{"line":61,"column":23},{"doc":"\"NBlack\""}]},{"tag":"Literal","contents":{"tag":"Str","contents":"NBlack"}}]]]]}]]}],{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"String"}}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"reportRemBug"},[{"tag":"Span","contents":[{"line":261,"column":10},{"line":266,"column":6},{"doc":"Native.Debug.crash\n  <| (String.concat\n        [\"Internal red-black tree invariant violated, expected \",\n         msg,\n         \" and got \",\n         showNColor c,\n         \"/\",\n         lgot,\n         \"/\",\n         rgot,\n         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"msg"},[{"tag":"Span","contents":[{"line":261,"column":10},{"line":266,"column":6},{"doc":"Native.Debug.crash\n  <| (String.concat\n        [\"Internal red-black tree invariant violated, expected \",\n         msg,\n         \" and got \",\n         showNColor c,\n         \"/\",\n         lgot,\n         \"/\",\n         rgot,\n         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"c"},[{"tag":"Span","contents":[{"line":261,"column":10},{"line":266,"column":6},{"doc":"Native.Debug.crash\n  <| (String.concat\n        [\"Internal red-black tree invariant violated, expected \",\n         msg,\n         \" and got \",\n         showNColor c,\n         \"/\",\n         lgot,\n         \"/\",\n         rgot,\n         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"lgot"},[{"tag":"Span","contents":[{"line":261,"column":10},{"line":266,"column":6},{"doc":"Native.Debug.crash\n  <| (String.concat\n        [\"Internal red-black tree invariant violated, expected \",\n         msg,\n         \" and got \",\n         showNColor c,\n         \"/\",\n         lgot,\n         \"/\",\n         rgot,\n         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"rgot"},[{"tag":"Span","contents":[{"line":261,"column":10},{"line":266,"column":6},{"doc":"Native.Debug.crash\n  <| (String.concat\n        [\"Internal red-black tree invariant violated, expected \",\n         msg,\n         \" and got \",\n         showNColor c,\n         \"/\",\n         lgot,\n         \"/\",\n         rgot,\n         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])"}]},{"tag":"Binop","contents":[{"home":{"tag":"Module","contents":["Basics"]},"name":"<|"},[{"tag":"Span","contents":[{"line":261,"column":10},{"line":261,"column":21},{"doc":"Native.Debug.crash"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","Debug"]},"name":"crash"}}],[{"tag":"Span","contents":[{"line":262,"column":5},{"line":266,"column":6},{"doc":"String.concat\n  [\"Internal red-black tree invariant violated, expected \",\n   msg,\n   \" and got \",\n   showNColor c,\n   \"/\",\n   lgot,\n   \"/\",\n   rgot,\n   \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"]"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":262,"column":5},{"line":262,"column":18},{"doc":"String.concat"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["String"]},"name":"concat"}}],[{"tag":"Span","contents":[{"line":263,"column":5},{"line":266,"column":6},{"doc":"[\"Internal red-black tree invariant violated, expected \",\n msg,\n \" and got \",\n showNColor c,\n \"/\",\n lgot,\n \"/\",\n rgot,\n \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"]"}]},{"tag":"ExplicitList","contents":[[{"tag":"Span","contents":[{"line":263,"column":7},{"line":263,"column":62},{"doc":"\"Internal red-black tree invariant violated, expected \""}]},{"tag":"Literal","contents":{"tag":"Str","contents":"Internal red-black tree invariant violated, expected "}}],[{"tag":"Span","contents":[{"line":264,"column":7},{"line":264,"column":10},{"doc":"msg"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"msg"}}],[{"tag":"Span","contents":[{"line":264,"column":12},{"line":264,"column":23},{"doc":"\" and got \""}]},{"tag":"Literal","contents":{"tag":"Str","contents":" and got "}}],[{"tag":"Span","contents":[{"line":264,"column":25},{"line":264,"column":37},{"doc":"showNColor c"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":264,"column":25},{"line":264,"column":35},{"doc":"showNColor"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"showNColor"}}],[{"tag":"Span","contents":[{"line":264,"column":36},{"line":264,"column":37},{"doc":"c"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"c"}}]]}],[{"tag":"Span","contents":[{"line":264,"column":39},{"line":264,"column":42},{"doc":"\"/\""}]},{"tag":"Literal","contents":{"tag":"Str","contents":"/"}}],[{"tag":"Span","contents":[{"line":264,"column":44},{"line":264,"column":48},{"doc":"lgot"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"lgot"}}],[{"tag":"Span","contents":[{"line":264,"column":50},{"line":264,"column":53},{"doc":"\"/\""}]},{"tag":"Literal","contents":{"tag":"Str","contents":"/"}}],[{"tag":"Span","contents":[{"line":264,"column":55},{"line":264,"column":59},{"doc":"rgot"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"rgot"}}],[{"tag":"Span","contents":[{"line":265,"column":7},{"line":265,"column":77},{"doc":"\"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\""}]},{"tag":"Literal","contents":{"tag":"Str","contents":"\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>"}}]]}]]}]]}]]}]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"String"}},{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"String"}},{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"String"}},{"tag":"Var","contents":"a"}]}]}]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"NBlack"},[{"tag":"None","contents":{"doc":"NBlack"}},{"tag":"Data","contents":["NBlack",[]]}],{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},[]]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"BBlack"},[{"tag":"None","contents":{"doc":"BBlack"}},{"tag":"Data","contents":["BBlack",[]]}],{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},[]]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"Black"},[{"tag":"None","contents":{"doc":"Black"}},{"tag":"Data","contents":["Black",[]]}],{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},[]]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"ensureBlackRoot"},[{"tag":"Span","contents":[{"line":146,"column":5},{"line":158,"column":16},{"doc":"case dict of\n  RBNode Red key value left right -> RBNode\n                                       Black key value left right\n  RBNode Black _ _ _ _ -> dict\n  RBEmpty LBlack -> dict"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"dict"},[{"tag":"Span","contents":[{"line":146,"column":5},{"line":158,"column":16},{"doc":"case dict of\n  RBNode Red key value left right -> RBNode\n                                       Black key value left right\n  RBNode Black _ _ _ _ -> dict\n  RBEmpty LBlack -> dict"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":146,"column":10},{"line":146,"column":14},{"doc":"dict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"dict"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Red"},[]]},{"tag":"Var","contents":"key"},{"tag":"Var","contents":"value"},{"tag":"Var","contents":"left"},{"tag":"Var","contents":"right"}]]},[{"tag":"Span","contents":[{"line":148,"column":11},{"line":148,"column":44},{"doc":"RBNode Black key value left right"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":148,"column":11},{"line":148,"column":38},{"doc":"RBNode Black key value left"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":148,"column":11},{"line":148,"column":33},{"doc":"RBNode Black key value"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":148,"column":11},{"line":148,"column":27},{"doc":"RBNode Black key"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":148,"column":11},{"line":148,"column":23},{"doc":"RBNode Black"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":148,"column":11},{"line":148,"column":17},{"doc":"RBNode"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBNode"}}],[{"tag":"Span","contents":[{"line":148,"column":18},{"line":148,"column":23},{"doc":"Black"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Black"}}]]}],[{"tag":"Span","contents":[{"line":148,"column":24},{"line":148,"column":27},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}]]}],[{"tag":"Span","contents":[{"line":148,"column":28},{"line":148,"column":33},{"doc":"value"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"value"}}]]}],[{"tag":"Span","contents":[{"line":148,"column":34},{"line":148,"column":38},{"doc":"left"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"left"}}]]}],[{"tag":"Span","contents":[{"line":148,"column":39},{"line":148,"column":44},{"doc":"right"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"right"}}]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Black"},[]]},{"tag":"Anything","contents":[]},{"tag":"Anything","contents":[]},{"tag":"Anything","contents":[]},{"tag":"Anything","contents":[]}]]},[{"tag":"Span","contents":[{"line":151,"column":11},{"line":151,"column":15},{"doc":"dict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"dict"}}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBEmpty"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"LBlack"},[]]}]]},[{"tag":"Span","contents":[{"line":154,"column":11},{"line":154,"column":15},{"doc":"dict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"dict"}}]]]]}]]}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"blackish"},[{"tag":"Span","contents":[{"line":331,"column":5},{"line":333,"column":31},{"doc":"case t of\n  RBNode c _ _ _ _ -> (c == Black) || (c == BBlack)\n  RBEmpty _ -> True"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"t"},[{"tag":"Span","contents":[{"line":331,"column":5},{"line":333,"column":31},{"doc":"case t of\n  RBNode c _ _ _ _ -> (c == Black) || (c == BBlack)\n  RBEmpty _ -> True"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":331,"column":10},{"line":331,"column":11},{"doc":"t"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"t"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Var","contents":"c"},{"tag":"Anything","contents":[]},{"tag":"Anything","contents":[]},{"tag":"Anything","contents":[]},{"tag":"Anything","contents":[]}]]},[{"tag":"Span","contents":[{"line":332,"column":27},{"line":332,"column":52},{"doc":"(c == Black) || (c == BBlack)"}]},{"tag":"Binop","contents":[{"home":{"tag":"Module","contents":["Basics"]},"name":"||"},[{"tag":"Span","contents":[{"line":332,"column":27},{"line":332,"column":37},{"doc":"c == Black"}]},{"tag":"Binop","contents":[{"home":{"tag":"Module","contents":["Basics"]},"name":"=="},[{"tag":"Span","contents":[{"line":332,"column":27},{"line":332,"column":28},{"doc":"c"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"c"}}],[{"tag":"Span","contents":[{"line":332,"column":32},{"line":332,"column":37},{"doc":"Black"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Black"}}]]}],[{"tag":"Span","contents":[{"line":332,"column":41},{"line":332,"column":52},{"doc":"c == BBlack"}]},{"tag":"Binop","contents":[{"home":{"tag":"Module","contents":["Basics"]},"name":"=="},[{"tag":"Span","contents":[{"line":332,"column":41},{"line":332,"column":42},{"doc":"c"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"c"}}],[{"tag":"Span","contents":[{"line":332,"column":46},{"line":332,"column":52},{"doc":"BBlack"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"BBlack"}}]]}]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBEmpty"},[{"tag":"Anything","contents":[]}]]},[{"tag":"Span","contents":[{"line":333,"column":27},{"line":333,"column":31},{"doc":"True"}]},{"tag":"Literal","contents":{"tag":"Boolean","contents":true}}]]]]}]]}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"blacken"},[{"tag":"Span","contents":[{"line":370,"column":5},{"line":372,"column":47},{"doc":"case t of\n  RBEmpty _ -> RBEmpty LBlack\n  RBNode _ k v l r -> RBNode Black k v l r"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"t"},[{"tag":"Span","contents":[{"line":370,"column":5},{"line":372,"column":47},{"doc":"case t of\n  RBEmpty _ -> RBEmpty LBlack\n  RBNode _ k v l r -> RBNode Black k v l r"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":370,"column":10},{"line":370,"column":11},{"doc":"t"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"t"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBEmpty"},[{"tag":"Anything","contents":[]}]]},[{"tag":"Span","contents":[{"line":371,"column":20},{"line":371,"column":34},{"doc":"RBEmpty LBlack"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":371,"column":20},{"line":371,"column":27},{"doc":"RBEmpty"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBEmpty"}}],[{"tag":"Span","contents":[{"line":371,"column":28},{"line":371,"column":34},{"doc":"LBlack"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"LBlack"}}]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Anything","contents":[]},{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"},{"tag":"Var","contents":"l"},{"tag":"Var","contents":"r"}]]},[{"tag":"Span","contents":[{"line":372,"column":27},{"line":372,"column":47},{"doc":"RBNode Black k v l r"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":372,"column":27},{"line":372,"column":45},{"doc":"RBNode Black k v l"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":372,"column":27},{"line":372,"column":43},{"doc":"RBNode Black k v"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":372,"column":27},{"line":372,"column":41},{"doc":"RBNode Black k"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":372,"column":27},{"line":372,"column":39},{"doc":"RBNode Black"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":372,"column":27},{"line":372,"column":33},{"doc":"RBNode"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBNode"}}],[{"tag":"Span","contents":[{"line":372,"column":34},{"line":372,"column":39},{"doc":"Black"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Black"}}]]}],[{"tag":"Span","contents":[{"line":372,"column":40},{"line":372,"column":41},{"doc":"k"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"k"}}]]}],[{"tag":"Span","contents":[{"line":372,"column":42},{"line":372,"column":43},{"doc":"v"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"v"}}]]}],[{"tag":"Span","contents":[{"line":372,"column":44},{"line":372,"column":45},{"doc":"l"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"l"}}]]}],[{"tag":"Span","contents":[{"line":372,"column":46},{"line":372,"column":47},{"doc":"r"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"r"}}]]}]]]]}]]}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"Red"},[{"tag":"None","contents":{"doc":"Red"}},{"tag":"Data","contents":["Red",[]]}],{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},[]]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"moreBlack"},[{"tag":"Span","contents":[{"line":236,"column":5},{"line":240,"column":80},{"doc":"case color of\n  Black -> BBlack\n  Red -> Black\n  NBlack -> Red\n  BBlack -> Native.Debug.crash\n              \"Can't make a double black node more black!\""}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"color"},[{"tag":"Span","contents":[{"line":236,"column":5},{"line":240,"column":80},{"doc":"case color of\n  Black -> BBlack\n  Red -> Black\n  NBlack -> Red\n  BBlack -> Native.Debug.crash\n              \"Can't make a double black node more black!\""}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":236,"column":10},{"line":236,"column":15},{"doc":"color"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"color"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Black"},[]]},[{"tag":"Span","contents":[{"line":237,"column":17},{"line":237,"column":23},{"doc":"BBlack"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"BBlack"}}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Red"},[]]},[{"tag":"Span","contents":[{"line":238,"column":17},{"line":238,"column":22},{"doc":"Black"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Black"}}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"NBlack"},[]]},[{"tag":"Span","contents":[{"line":239,"column":17},{"line":239,"column":20},{"doc":"Red"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Red"}}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"BBlack"},[]]},[{"tag":"Span","contents":[{"line":240,"column":24},{"line":240,"column":80},{"doc":"Native.Debug.crash \"Can't make a double black node more black!\""}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":240,"column":24},{"line":240,"column":35},{"doc":"Native.Debug.crash"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","Debug"]},"name":"crash"}}],[{"tag":"Span","contents":[{"line":240,"column":36},{"line":240,"column":80},{"doc":"\"Can't make a double black node more black!\""}]},{"tag":"Literal","contents":{"tag":"Str","contents":"Can't make a double black node more black!"}}]]}]]]]}]]}],{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"lessBlack"},[{"tag":"Span","contents":[{"line":245,"column":5},{"line":249,"column":82},{"doc":"case color of\n  BBlack -> Black\n  Black -> Red\n  Red -> NBlack\n  NBlack -> Native.Debug.crash\n              \"Can't make a negative black node less black!\""}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"color"},[{"tag":"Span","contents":[{"line":245,"column":5},{"line":249,"column":82},{"doc":"case color of\n  BBlack -> Black\n  Black -> Red\n  Red -> NBlack\n  NBlack -> Native.Debug.crash\n              \"Can't make a negative black node less black!\""}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":245,"column":10},{"line":245,"column":15},{"doc":"color"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"color"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"BBlack"},[]]},[{"tag":"Span","contents":[{"line":246,"column":17},{"line":246,"column":22},{"doc":"Black"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Black"}}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Black"},[]]},[{"tag":"Span","contents":[{"line":247,"column":17},{"line":247,"column":20},{"doc":"Red"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Red"}}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Red"},[]]},[{"tag":"Span","contents":[{"line":248,"column":17},{"line":248,"column":23},{"doc":"NBlack"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"NBlack"}}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"NBlack"},[]]},[{"tag":"Span","contents":[{"line":249,"column":24},{"line":249,"column":82},{"doc":"Native.Debug.crash \"Can't make a negative black node less black!\""}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":249,"column":24},{"line":249,"column":35},{"doc":"Native.Debug.crash"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","Debug"]},"name":"crash"}}],[{"tag":"Span","contents":[{"line":249,"column":36},{"line":249,"column":82},{"doc":"\"Can't make a negative black node less black!\""}]},{"tag":"Literal","contents":{"tag":"Str","contents":"Can't make a negative black node less black!"}}]]}]]]]}]]}],{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"lessBlackTree"},[{"tag":"Span","contents":[{"line":254,"column":5},{"line":256,"column":40},{"doc":"case dict of\n  RBNode c k v l r -> RBNode (lessBlack c) k v l r\n  RBEmpty LBBlack -> RBEmpty LBlack"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"dict"},[{"tag":"Span","contents":[{"line":254,"column":5},{"line":256,"column":40},{"doc":"case dict of\n  RBNode c k v l r -> RBNode (lessBlack c) k v l r\n  RBEmpty LBBlack -> RBEmpty LBlack"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":254,"column":10},{"line":254,"column":14},{"doc":"dict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"dict"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Var","contents":"c"},{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"},{"tag":"Var","contents":"l"},{"tag":"Var","contents":"r"}]]},[{"tag":"Span","contents":[{"line":255,"column":27},{"line":255,"column":55},{"doc":"RBNode (lessBlack c) k v l r"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":255,"column":27},{"line":255,"column":53},{"doc":"RBNode (lessBlack c) k v l"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":255,"column":27},{"line":255,"column":51},{"doc":"RBNode (lessBlack c) k v"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":255,"column":27},{"line":255,"column":49},{"doc":"RBNode (lessBlack c) k"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":255,"column":27},{"line":255,"column":46},{"doc":"RBNode (lessBlack c)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":255,"column":27},{"line":255,"column":33},{"doc":"RBNode"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBNode"}}],[{"tag":"Span","contents":[{"line":255,"column":35},{"line":255,"column":46},{"doc":"lessBlack c"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":255,"column":35},{"line":255,"column":44},{"doc":"lessBlack"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"lessBlack"}}],[{"tag":"Span","contents":[{"line":255,"column":45},{"line":255,"column":46},{"doc":"c"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"c"}}]]}]]}],[{"tag":"Span","contents":[{"line":255,"column":48},{"line":255,"column":49},{"doc":"k"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"k"}}]]}],[{"tag":"Span","contents":[{"line":255,"column":50},{"line":255,"column":51},{"doc":"v"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"v"}}]]}],[{"tag":"Span","contents":[{"line":255,"column":52},{"line":255,"column":53},{"doc":"l"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"l"}}]]}],[{"tag":"Span","contents":[{"line":255,"column":54},{"line":255,"column":55},{"doc":"r"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"r"}}]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBEmpty"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"LBBlack"},[]]}]]},[{"tag":"Span","contents":[{"line":256,"column":26},{"line":256,"column":40},{"doc":"RBEmpty LBlack"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":256,"column":26},{"line":256,"column":33},{"doc":"RBEmpty"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBEmpty"}}],[{"tag":"Span","contents":[{"line":256,"column":34},{"line":256,"column":40},{"doc":"LBlack"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"LBlack"}}]]}]]]]}]]}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"redden"},[{"tag":"Span","contents":[{"line":378,"column":5},{"line":383,"column":55},{"doc":"case t of\n  RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n  RBNode _ k v l r -> RBNode Red k v l r"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"t"},[{"tag":"Span","contents":[{"line":378,"column":5},{"line":383,"column":55},{"doc":"case t of\n  RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n  RBNode _ k v l r -> RBNode Red k v l r"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":378,"column":10},{"line":378,"column":11},{"doc":"t"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"t"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBEmpty"},[{"tag":"Anything","contents":[]}]]},[{"tag":"Span","contents":[{"line":379,"column":27},{"line":379,"column":62},{"doc":"Native.Debug.crash \"can't make a Leaf red\""}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":379,"column":27},{"line":379,"column":38},{"doc":"Native.Debug.crash"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","Debug"]},"name":"crash"}}],[{"tag":"Span","contents":[{"line":379,"column":39},{"line":379,"column":62},{"doc":"\"can't make a Leaf red\""}]},{"tag":"Literal","contents":{"tag":"Str","contents":"can't make a Leaf red"}}]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Anything","contents":[]},{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"},{"tag":"Var","contents":"l"},{"tag":"Var","contents":"r"}]]},[{"tag":"Span","contents":[{"line":380,"column":27},{"line":380,"column":45},{"doc":"RBNode Red k v l r"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":380,"column":27},{"line":380,"column":43},{"doc":"RBNode Red k v l"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":380,"column":27},{"line":380,"column":41},{"doc":"RBNode Red k v"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":380,"column":27},{"line":380,"column":39},{"doc":"RBNode Red k"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":380,"column":27},{"line":380,"column":37},{"doc":"RBNode Red"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":380,"column":27},{"line":380,"column":33},{"doc":"RBNode"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBNode"}}],[{"tag":"Span","contents":[{"line":380,"column":34},{"line":380,"column":37},{"doc":"Red"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Red"}}]]}],[{"tag":"Span","contents":[{"line":380,"column":38},{"line":380,"column":39},{"doc":"k"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"k"}}]]}],[{"tag":"Span","contents":[{"line":380,"column":40},{"line":380,"column":41},{"doc":"v"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"v"}}]]}],[{"tag":"Span","contents":[{"line":380,"column":42},{"line":380,"column":43},{"doc":"l"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"l"}}]]}],[{"tag":"Span","contents":[{"line":380,"column":44},{"line":380,"column":45},{"doc":"r"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"r"}}]]}]]]]}]]}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"balance_node"},[{"tag":"Span","contents":[{"line":338,"column":3},{"line":364,"column":10},{"doc":"let assemble = \\col xk xv yk yv zk zv a b c d -> RBNode\n                                                   (lessBlack col)\n                                                   yk\n                                                   yv\n                                                   (RBNode Black xk xv a b)\n                                                   (RBNode Black zk zv c d)\nin if | blackish t ->\n          case t of\n            RBNode col zk zv (RBNode Red yk yv (RBNode Red xk xv a b) c) d -> assemble\n                                                                                col\n                                                                                xk\n                                                                                xv\n                                                                                yk\n                                                                                yv\n                                                                                zk\n                                                                                zv\n                                                                                a\n                                                                                b\n                                                                                c\n                                                                                d\n            RBNode col zk zv (RBNode Red xk xv a (RBNode Red yk yv b c)) d -> assemble\n                                                                                col\n                                                                                xk\n                                                                                xv\n                                                                                yk\n                                                                                yv\n                                                                                zk\n                                                                                zv\n                                                                                a\n                                                                                b\n                                                                                c\n                                                                                d\n            RBNode col xk xv a (RBNode Red zk zv (RBNode Red yk yv b c) d) -> assemble\n                                                                                col\n                                                                                xk\n                                                                                xv\n                                                                                yk\n                                                                                yv\n                                                                                zk\n                                                                                zv\n                                                                                a\n                                                                                b\n                                                                                c\n                                                                                d\n            RBNode col xk xv a (RBNode Red yk yv b (RBNode Red zk zv c d)) -> assemble\n                                                                                col\n                                                                                xk\n                                                                                xv\n                                                                                yk\n                                                                                yv\n                                                                                zk\n                                                                                zv\n                                                                                a\n                                                                                b\n                                                                                c\n                                                                                d\n            RBNode BBlack xk xv a (RBNode NBlack zk zv (RBNode Black yk yv b c) d) -> case d\n                                                                                      of\n                                                                                        RBNode Black _ _ _ _ -> RBNode\n                                                                                                                  Black\n                                                                                                                  yk\n                                                                                                                  yv\n                                                                                                                  (RBNode\n                                                                                                                     Black\n                                                                                                                     xk\n                                                                                                                     xv\n                                                                                                                     a\n                                                                                                                     b)\n                                                                                                                  (balance\n                                                                                                                     Black\n                                                                                                                     zk\n                                                                                                                     zv\n                                                                                                                     c\n                                                                                                                     (redden\n                                                                                                                        d))\n                                                                                        _ -> t\n            RBNode BBlack zk zv (RBNode NBlack xk xv a (RBNode Black yk yv b c)) d -> case a\n                                                                                      of\n                                                                                        RBNode Black _ _ _ _ -> RBNode\n                                                                                                                  Black\n                                                                                                                  yk\n                                                                                                                  yv\n                                                                                                                  (balance\n                                                                                                                     Black\n                                                                                                                     xk\n                                                                                                                     xv\n                                                                                                                     (redden\n                                                                                                                        a)\n                                                                                                                     b)\n                                                                                                                  (RBNode\n                                                                                                                     Black\n                                                                                                                     zk\n                                                                                                                     zv\n                                                                                                                     c\n                                                                                                                     d)\n                                                                                        _ -> t\n            _ -> t\n      | True -> t"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"t"},[{"tag":"Span","contents":[{"line":338,"column":3},{"line":364,"column":10},{"doc":"let assemble = \\col xk xv yk yv zk zv a b c d -> RBNode\n                                                   (lessBlack col)\n                                                   yk\n                                                   yv\n                                                   (RBNode Black xk xv a b)\n                                                   (RBNode Black zk zv c d)\nin if | blackish t ->\n          case t of\n            RBNode col zk zv (RBNode Red yk yv (RBNode Red xk xv a b) c) d -> assemble\n                                                                                col\n                                                                                xk\n                                                                                xv\n                                                                                yk\n                                                                                yv\n                                                                                zk\n                                                                                zv\n                                                                                a\n                                                                                b\n                                                                                c\n                                                                                d\n            RBNode col zk zv (RBNode Red xk xv a (RBNode Red yk yv b c)) d -> assemble\n                                                                                col\n                                                                                xk\n                                                                                xv\n                                                                                yk\n                                                                                yv\n                                                                                zk\n                                                                                zv\n                                                                                a\n                                                                                b\n                                                                                c\n                                                                                d\n            RBNode col xk xv a (RBNode Red zk zv (RBNode Red yk yv b c) d) -> assemble\n                                                                                col\n                                                                                xk\n                                                                                xv\n                                                                                yk\n                                                                                yv\n                                                                                zk\n                                                                                zv\n                                                                                a\n                                                                                b\n                                                                                c\n                                                                                d\n            RBNode col xk xv a (RBNode Red yk yv b (RBNode Red zk zv c d)) -> assemble\n                                                                                col\n                                                                                xk\n                                                                                xv\n                                                                                yk\n                                                                                yv\n                                                                                zk\n                                                                                zv\n                                                                                a\n                                                                                b\n                                                                                c\n                                                                                d\n            RBNode BBlack xk xv a (RBNode NBlack zk zv (RBNode Black yk yv b c) d) -> case d\n                                                                                      of\n                                                                                        RBNode Black _ _ _ _ -> RBNode\n                                                                                                                  Black\n                                                                                                                  yk\n                                                                                                                  yv\n                                                                                                                  (RBNode\n                                                                                                                     Black\n                                                                                                                     xk\n                                                                                                                     xv\n                                                                                                                     a\n                                                                                                                     b)\n                                                                                                                  (balance\n                                                                                                                     Black\n                                                                                                                     zk\n                                                                                                                     zv\n                                                                                                                     c\n                                                                                                                     (redden\n                                                                                                                        d))\n                                                                                        _ -> t\n            RBNode BBlack zk zv (RBNode NBlack xk xv a (RBNode Black yk yv b c)) d -> case a\n                                                                                      of\n                                                                                        RBNode Black _ _ _ _ -> RBNode\n                                                                                                                  Black\n                                                                                                                  yk\n                                                                                                                  yv\n                                                                                                                  (balance\n                                                                                                                     Black\n                                                                                                                     xk\n                                                                                                                     xv\n                                                                                                                     (redden\n                                                                                                                        a)\n                                                                                                                     b)\n                                                                                                                  (RBNode\n                                                                                                                     Black\n                                                                                                                     zk\n                                                                                                                     zv\n                                                                                                                     c\n                                                                                                                     d)\n                                                                                        _ -> t\n            _ -> t\n      | True -> t"}]},{"tag":"Let","contents":[[[{"tag":"Var","contents":"assemble"},[{"tag":"Span","contents":[{"line":339,"column":9},{"line":339,"column":86},{"doc":"RBNode\n  (lessBlack col)\n  yk\n  yv\n  (RBNode Black xk xv a b)\n  (RBNode Black zk zv c d)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"col"},[{"tag":"Span","contents":[{"line":339,"column":9},{"line":339,"column":86},{"doc":"RBNode\n  (lessBlack col)\n  yk\n  yv\n  (RBNode Black xk xv a b)\n  (RBNode Black zk zv c d)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"xk"},[{"tag":"Span","contents":[{"line":339,"column":9},{"line":339,"column":86},{"doc":"RBNode\n  (lessBlack col)\n  yk\n  yv\n  (RBNode Black xk xv a b)\n  (RBNode Black zk zv c d)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"xv"},[{"tag":"Span","contents":[{"line":339,"column":9},{"line":339,"column":86},{"doc":"RBNode\n  (lessBlack col)\n  yk\n  yv\n  (RBNode Black xk xv a b)\n  (RBNode Black zk zv c d)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"yk"},[{"tag":"Span","contents":[{"line":339,"column":9},{"line":339,"column":86},{"doc":"RBNode\n  (lessBlack col)\n  yk\n  yv\n  (RBNode Black xk xv a b)\n  (RBNode Black zk zv c d)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"yv"},[{"tag":"Span","contents":[{"line":339,"column":9},{"line":339,"column":86},{"doc":"RBNode\n  (lessBlack col)\n  yk\n  yv\n  (RBNode Black xk xv a b)\n  (RBNode Black zk zv c d)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"zk"},[{"tag":"Span","contents":[{"line":339,"column":9},{"line":339,"column":86},{"doc":"RBNode\n  (lessBlack col)\n  yk\n  yv\n  (RBNode Black xk xv a b)\n  (RBNode Black zk zv c d)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"zv"},[{"tag":"Span","contents":[{"line":339,"column":9},{"line":339,"column":86},{"doc":"RBNode\n  (lessBlack col)\n  yk\n  yv\n  (RBNode Black xk xv a b)\n  (RBNode Black zk zv c d)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},[{"tag":"Span","contents":[{"line":339,"column":9},{"line":339,"column":86},{"doc":"RBNode\n  (lessBlack col)\n  yk\n  yv\n  (RBNode Black xk xv a b)\n  (RBNode Black zk zv c d)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},[{"tag":"Span","contents":[{"line":339,"column":9},{"line":339,"column":86},{"doc":"RBNode\n  (lessBlack col)\n  yk\n  yv\n  (RBNode Black xk xv a b)\n  (RBNode Black zk zv c d)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"c"},[{"tag":"Span","contents":[{"line":339,"column":9},{"line":339,"column":86},{"doc":"RBNode\n  (lessBlack col)\n  yk\n  yv\n  (RBNode Black xk xv a b)\n  (RBNode Black zk zv c d)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"d"},[{"tag":"Span","contents":[{"line":339,"column":9},{"line":339,"column":86},{"doc":"RBNode\n  (lessBlack col)\n  yk\n  yv\n  (RBNode Black xk xv a b)\n  (RBNode Black zk zv c d)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":339,"column":9},{"line":339,"column":61},{"doc":"RBNode (lessBlack col) yk yv (RBNode Black xk xv a b)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":339,"column":9},{"line":339,"column":37},{"doc":"RBNode (lessBlack col) yk yv"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":339,"column":9},{"line":339,"column":34},{"doc":"RBNode (lessBlack col) yk"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":339,"column":9},{"line":339,"column":30},{"doc":"RBNode (lessBlack col)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":339,"column":9},{"line":339,"column":15},{"doc":"RBNode"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBNode"}}],[{"tag":"Span","contents":[{"line":339,"column":17},{"line":339,"column":30},{"doc":"lessBlack col"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":339,"column":17},{"line":339,"column":26},{"doc":"lessBlack"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"lessBlack"}}],[{"tag":"Span","contents":[{"line":339,"column":27},{"line":339,"column":30},{"doc":"col"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"col"}}]]}]]}],[{"tag":"Span","contents":[{"line":339,"column":32},{"line":339,"column":34},{"doc":"yk"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"yk"}}]]}],[{"tag":"Span","contents":[{"line":339,"column":35},{"line":339,"column":37},{"doc":"yv"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"yv"}}]]}],[{"tag":"Span","contents":[{"line":339,"column":39},{"line":339,"column":61},{"doc":"RBNode Black xk xv a b"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":339,"column":39},{"line":339,"column":59},{"doc":"RBNode Black xk xv a"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":339,"column":39},{"line":339,"column":57},{"doc":"RBNode Black xk xv"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":339,"column":39},{"line":339,"column":54},{"doc":"RBNode Black xk"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":339,"column":39},{"line":339,"column":51},{"doc":"RBNode Black"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":339,"column":39},{"line":339,"column":45},{"doc":"RBNode"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBNode"}}],[{"tag":"Span","contents":[{"line":339,"column":46},{"line":339,"column":51},{"doc":"Black"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Black"}}]]}],[{"tag":"Span","contents":[{"line":339,"column":52},{"line":339,"column":54},{"doc":"xk"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"xk"}}]]}],[{"tag":"Span","contents":[{"line":339,"column":55},{"line":339,"column":57},{"doc":"xv"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"xv"}}]]}],[{"tag":"Span","contents":[{"line":339,"column":58},{"line":339,"column":59},{"doc":"a"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"a"}}]]}],[{"tag":"Span","contents":[{"line":339,"column":60},{"line":339,"column":61},{"doc":"b"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"b"}}]]}]]}],[{"tag":"Span","contents":[{"line":339,"column":64},{"line":339,"column":86},{"doc":"RBNode Black zk zv c d"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":339,"column":64},{"line":339,"column":84},{"doc":"RBNode Black zk zv c"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":339,"column":64},{"line":339,"column":82},{"doc":"RBNode Black zk zv"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":339,"column":64},{"line":339,"column":79},{"doc":"RBNode Black zk"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":339,"column":64},{"line":339,"column":76},{"doc":"RBNode Black"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":339,"column":64},{"line":339,"column":70},{"doc":"RBNode"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBNode"}}],[{"tag":"Span","contents":[{"line":339,"column":71},{"line":339,"column":76},{"doc":"Black"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Black"}}]]}],[{"tag":"Span","contents":[{"line":339,"column":77},{"line":339,"column":79},{"doc":"zk"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"zk"}}]]}],[{"tag":"Span","contents":[{"line":339,"column":80},{"line":339,"column":82},{"doc":"zv"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"zv"}}]]}],[{"tag":"Span","contents":[{"line":339,"column":83},{"line":339,"column":84},{"doc":"c"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"c"}}]]}],[{"tag":"Span","contents":[{"line":339,"column":85},{"line":339,"column":86},{"doc":"d"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"d"}}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}],null]],[{"tag":"Span","contents":[{"line":341,"column":4},{"line":364,"column":10},{"doc":"if | blackish t ->\n       case t of\n         RBNode col zk zv (RBNode Red yk yv (RBNode Red xk xv a b) c) d -> assemble\n                                                                             col\n                                                                             xk\n                                                                             xv\n                                                                             yk\n                                                                             yv\n                                                                             zk\n                                                                             zv\n                                                                             a\n                                                                             b\n                                                                             c\n                                                                             d\n         RBNode col zk zv (RBNode Red xk xv a (RBNode Red yk yv b c)) d -> assemble\n                                                                             col\n                                                                             xk\n                                                                             xv\n                                                                             yk\n                                                                             yv\n                                                                             zk\n                                                                             zv\n                                                                             a\n                                                                             b\n                                                                             c\n                                                                             d\n         RBNode col xk xv a (RBNode Red zk zv (RBNode Red yk yv b c) d) -> assemble\n                                                                             col\n                                                                             xk\n                                                                             xv\n                                                                             yk\n                                                                             yv\n                                                                             zk\n                                                                             zv\n                                                                             a\n                                                                             b\n                                                                             c\n                                                                             d\n         RBNode col xk xv a (RBNode Red yk yv b (RBNode Red zk zv c d)) -> assemble\n                                                                             col\n                                                                             xk\n                                                                             xv\n                                                                             yk\n                                                                             yv\n                                                                             zk\n                                                                             zv\n                                                                             a\n                                                                             b\n                                                                             c\n                                                                             d\n         RBNode BBlack xk xv a (RBNode NBlack zk zv (RBNode Black yk yv b c) d) -> case d\n                                                                                   of\n                                                                                     RBNode Black _ _ _ _ -> RBNode\n                                                                                                               Black\n                                                                                                               yk\n                                                                                                               yv\n                                                                                                               (RBNode\n                                                                                                                  Black\n                                                                                                                  xk\n                                                                                                                  xv\n                                                                                                                  a\n                                                                                                                  b)\n                                                                                                               (balance\n                                                                                                                  Black\n                                                                                                                  zk\n                                                                                                                  zv\n                                                                                                                  c\n                                                                                                                  (redden\n                                                                                                                     d))\n                                                                                     _ -> t\n         RBNode BBlack zk zv (RBNode NBlack xk xv a (RBNode Black yk yv b c)) d -> case a\n                                                                                   of\n                                                                                     RBNode Black _ _ _ _ -> RBNode\n                                                                                                               Black\n                                                                                                               yk\n                                                                                                               yv\n                                                                                                               (balance\n                                                                                                                  Black\n                                                                                                                  xk\n                                                                                                                  xv\n                                                                                                                  (redden\n                                                                                                                     a)\n                                                                                                                  b)\n                                                                                                               (RBNode\n                                                                                                                  Black\n                                                                                                                  zk\n                                                                                                                  zv\n                                                                                                                  c\n                                                                                                                  d)\n                                                                                     _ -> t\n         _ -> t\n   | True -> t"}]},{"tag":"MultiIf","contents":[[[{"tag":"Span","contents":[{"line":341,"column":7},{"line":341,"column":17},{"doc":"blackish t"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":341,"column":7},{"line":341,"column":15},{"doc":"blackish"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"blackish"}}],[{"tag":"Span","contents":[{"line":341,"column":16},{"line":341,"column":17},{"doc":"t"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"t"}}]]}],[{"tag":"Span","contents":[{"line":342,"column":9},{"line":364,"column":4},{"doc":"case t of\n  RBNode col zk zv (RBNode Red yk yv (RBNode Red xk xv a b) c) d -> assemble\n                                                                      col xk xv yk yv zk zv a b c d\n  RBNode col zk zv (RBNode Red xk xv a (RBNode Red yk yv b c)) d -> assemble\n                                                                      col xk xv yk yv zk zv a b c d\n  RBNode col xk xv a (RBNode Red zk zv (RBNode Red yk yv b c) d) -> assemble\n                                                                      col xk xv yk yv zk zv a b c d\n  RBNode col xk xv a (RBNode Red yk yv b (RBNode Red zk zv c d)) -> assemble\n                                                                      col xk xv yk yv zk zv a b c d\n  RBNode BBlack xk xv a (RBNode NBlack zk zv (RBNode Black yk yv b c) d) -> case d\n                                                                            of\n                                                                              RBNode Black _ _ _ _ -> RBNode\n                                                                                                        Black\n                                                                                                        yk\n                                                                                                        yv\n                                                                                                        (RBNode\n                                                                                                           Black\n                                                                                                           xk\n                                                                                                           xv\n                                                                                                           a\n                                                                                                           b)\n                                                                                                        (balance\n                                                                                                           Black\n                                                                                                           zk\n                                                                                                           zv\n                                                                                                           c\n                                                                                                           (redden\n                                                                                                              d))\n                                                                              _ -> t\n  RBNode BBlack zk zv (RBNode NBlack xk xv a (RBNode Black yk yv b c)) d -> case a\n                                                                            of\n                                                                              RBNode Black _ _ _ _ -> RBNode\n                                                                                                        Black\n                                                                                                        yk\n                                                                                                        yv\n                                                                                                        (balance\n                                                                                                           Black\n                                                                                                           xk\n                                                                                                           xv\n                                                                                                           (redden\n                                                                                                              a)\n                                                                                                           b)\n                                                                                                        (RBNode\n                                                                                                           Black\n                                                                                                           zk\n                                                                                                           zv\n                                                                                                           c\n                                                                                                           d)\n                                                                              _ -> t\n  _ -> t"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":342,"column":14},{"line":342,"column":15},{"doc":"t"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"t"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Var","contents":"col"},{"tag":"Var","contents":"zk"},{"tag":"Var","contents":"zv"},{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Red"},[]]},{"tag":"Var","contents":"yk"},{"tag":"Var","contents":"yv"},{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Red"},[]]},{"tag":"Var","contents":"xk"},{"tag":"Var","contents":"xv"},{"tag":"Var","contents":"a"},{"tag":"Var","contents":"b"}]]},{"tag":"Var","contents":"c"}]]},{"tag":"Var","contents":"d"}]]},[{"tag":"Span","contents":[{"line":344,"column":8},{"line":344,"column":46},{"doc":"assemble col xk xv yk yv zk zv a b c d"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":344,"column":8},{"line":344,"column":44},{"doc":"assemble col xk xv yk yv zk zv a b c"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":344,"column":8},{"line":344,"column":42},{"doc":"assemble col xk xv yk yv zk zv a b"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":344,"column":8},{"line":344,"column":40},{"doc":"assemble col xk xv yk yv zk zv a"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":344,"column":8},{"line":344,"column":38},{"doc":"assemble col xk xv yk yv zk zv"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":344,"column":8},{"line":344,"column":35},{"doc":"assemble col xk xv yk yv zk"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":344,"column":8},{"line":344,"column":32},{"doc":"assemble col xk xv yk yv"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":344,"column":8},{"line":344,"column":29},{"doc":"assemble col xk xv yk"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":344,"column":8},{"line":344,"column":26},{"doc":"assemble col xk xv"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":344,"column":8},{"line":344,"column":23},{"doc":"assemble col xk"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":344,"column":8},{"line":344,"column":20},{"doc":"assemble col"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":344,"column":8},{"line":344,"column":16},{"doc":"assemble"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"assemble"}}],[{"tag":"Span","contents":[{"line":344,"column":17},{"line":344,"column":20},{"doc":"col"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"col"}}]]}],[{"tag":"Span","contents":[{"line":344,"column":21},{"line":344,"column":23},{"doc":"xk"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"xk"}}]]}],[{"tag":"Span","contents":[{"line":344,"column":24},{"line":344,"column":26},{"doc":"xv"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"xv"}}]]}],[{"tag":"Span","contents":[{"line":344,"column":27},{"line":344,"column":29},{"doc":"yk"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"yk"}}]]}],[{"tag":"Span","contents":[{"line":344,"column":30},{"line":344,"column":32},{"doc":"yv"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"yv"}}]]}],[{"tag":"Span","contents":[{"line":344,"column":33},{"line":344,"column":35},{"doc":"zk"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"zk"}}]]}],[{"tag":"Span","contents":[{"line":344,"column":36},{"line":344,"column":38},{"doc":"zv"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"zv"}}]]}],[{"tag":"Span","contents":[{"line":344,"column":39},{"line":344,"column":40},{"doc":"a"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"a"}}]]}],[{"tag":"Span","contents":[{"line":344,"column":41},{"line":344,"column":42},{"doc":"b"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"b"}}]]}],[{"tag":"Span","contents":[{"line":344,"column":43},{"line":344,"column":44},{"doc":"c"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"c"}}]]}],[{"tag":"Span","contents":[{"line":344,"column":45},{"line":344,"column":46},{"doc":"d"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"d"}}]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Var","contents":"col"},{"tag":"Var","contents":"zk"},{"tag":"Var","contents":"zv"},{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Red"},[]]},{"tag":"Var","contents":"xk"},{"tag":"Var","contents":"xv"},{"tag":"Var","contents":"a"},{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Red"},[]]},{"tag":"Var","contents":"yk"},{"tag":"Var","contents":"yv"},{"tag":"Var","contents":"b"},{"tag":"Var","contents":"c"}]]}]]},{"tag":"Var","contents":"d"}]]},[{"tag":"Span","contents":[{"line":346,"column":8},{"line":346,"column":46},{"doc":"assemble col xk xv yk yv zk zv a b c d"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":346,"column":8},{"line":346,"column":44},{"doc":"assemble col xk xv yk yv zk zv a b c"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":346,"column":8},{"line":346,"column":42},{"doc":"assemble col xk xv yk yv zk zv a b"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":346,"column":8},{"line":346,"column":40},{"doc":"assemble col xk xv yk yv zk zv a"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":346,"column":8},{"line":346,"column":38},{"doc":"assemble col xk xv yk yv zk zv"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":346,"column":8},{"line":346,"column":35},{"doc":"assemble col xk xv yk yv zk"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":346,"column":8},{"line":346,"column":32},{"doc":"assemble col xk xv yk yv"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":346,"column":8},{"line":346,"column":29},{"doc":"assemble col xk xv yk"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":346,"column":8},{"line":346,"column":26},{"doc":"assemble col xk xv"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":346,"column":8},{"line":346,"column":23},{"doc":"assemble col xk"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":346,"column":8},{"line":346,"column":20},{"doc":"assemble col"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":346,"column":8},{"line":346,"column":16},{"doc":"assemble"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"assemble"}}],[{"tag":"Span","contents":[{"line":346,"column":17},{"line":346,"column":20},{"doc":"col"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"col"}}]]}],[{"tag":"Span","contents":[{"line":346,"column":21},{"line":346,"column":23},{"doc":"xk"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"xk"}}]]}],[{"tag":"Span","contents":[{"line":346,"column":24},{"line":346,"column":26},{"doc":"xv"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"xv"}}]]}],[{"tag":"Span","contents":[{"line":346,"column":27},{"line":346,"column":29},{"doc":"yk"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"yk"}}]]}],[{"tag":"Span","contents":[{"line":346,"column":30},{"line":346,"column":32},{"doc":"yv"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"yv"}}]]}],[{"tag":"Span","contents":[{"line":346,"column":33},{"line":346,"column":35},{"doc":"zk"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"zk"}}]]}],[{"tag":"Span","contents":[{"line":346,"column":36},{"line":346,"column":38},{"doc":"zv"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"zv"}}]]}],[{"tag":"Span","contents":[{"line":346,"column":39},{"line":346,"column":40},{"doc":"a"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"a"}}]]}],[{"tag":"Span","contents":[{"line":346,"column":41},{"line":346,"column":42},{"doc":"b"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"b"}}]]}],[{"tag":"Span","contents":[{"line":346,"column":43},{"line":346,"column":44},{"doc":"c"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"c"}}]]}],[{"tag":"Span","contents":[{"line":346,"column":45},{"line":346,"column":46},{"doc":"d"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"d"}}]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Var","contents":"col"},{"tag":"Var","contents":"xk"},{"tag":"Var","contents":"xv"},{"tag":"Var","contents":"a"},{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Red"},[]]},{"tag":"Var","contents":"zk"},{"tag":"Var","contents":"zv"},{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Red"},[]]},{"tag":"Var","contents":"yk"},{"tag":"Var","contents":"yv"},{"tag":"Var","contents":"b"},{"tag":"Var","contents":"c"}]]},{"tag":"Var","contents":"d"}]]}]]},[{"tag":"Span","contents":[{"line":348,"column":8},{"line":348,"column":46},{"doc":"assemble col xk xv yk yv zk zv a b c d"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":348,"column":8},{"line":348,"column":44},{"doc":"assemble col xk xv yk yv zk zv a b c"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":348,"column":8},{"line":348,"column":42},{"doc":"assemble col xk xv yk yv zk zv a b"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":348,"column":8},{"line":348,"column":40},{"doc":"assemble col xk xv yk yv zk zv a"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":348,"column":8},{"line":348,"column":38},{"doc":"assemble col xk xv yk yv zk zv"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":348,"column":8},{"line":348,"column":35},{"doc":"assemble col xk xv yk yv zk"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":348,"column":8},{"line":348,"column":32},{"doc":"assemble col xk xv yk yv"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":348,"column":8},{"line":348,"column":29},{"doc":"assemble col xk xv yk"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":348,"column":8},{"line":348,"column":26},{"doc":"assemble col xk xv"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":348,"column":8},{"line":348,"column":23},{"doc":"assemble col xk"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":348,"column":8},{"line":348,"column":20},{"doc":"assemble col"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":348,"column":8},{"line":348,"column":16},{"doc":"assemble"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"assemble"}}],[{"tag":"Span","contents":[{"line":348,"column":17},{"line":348,"column":20},{"doc":"col"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"col"}}]]}],[{"tag":"Span","contents":[{"line":348,"column":21},{"line":348,"column":23},{"doc":"xk"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"xk"}}]]}],[{"tag":"Span","contents":[{"line":348,"column":24},{"line":348,"column":26},{"doc":"xv"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"xv"}}]]}],[{"tag":"Span","contents":[{"line":348,"column":27},{"line":348,"column":29},{"doc":"yk"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"yk"}}]]}],[{"tag":"Span","contents":[{"line":348,"column":30},{"line":348,"column":32},{"doc":"yv"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"yv"}}]]}],[{"tag":"Span","contents":[{"line":348,"column":33},{"line":348,"column":35},{"doc":"zk"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"zk"}}]]}],[{"tag":"Span","contents":[{"line":348,"column":36},{"line":348,"column":38},{"doc":"zv"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"zv"}}]]}],[{"tag":"Span","contents":[{"line":348,"column":39},{"line":348,"column":40},{"doc":"a"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"a"}}]]}],[{"tag":"Span","contents":[{"line":348,"column":41},{"line":348,"column":42},{"doc":"b"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"b"}}]]}],[{"tag":"Span","contents":[{"line":348,"column":43},{"line":348,"column":44},{"doc":"c"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"c"}}]]}],[{"tag":"Span","contents":[{"line":348,"column":45},{"line":348,"column":46},{"doc":"d"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"d"}}]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Var","contents":"col"},{"tag":"Var","contents":"xk"},{"tag":"Var","contents":"xv"},{"tag":"Var","contents":"a"},{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Red"},[]]},{"tag":"Var","contents":"yk"},{"tag":"Var","contents":"yv"},{"tag":"Var","contents":"b"},{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Red"},[]]},{"tag":"Var","contents":"zk"},{"tag":"Var","contents":"zv"},{"tag":"Var","contents":"c"},{"tag":"Var","contents":"d"}]]}]]}]]},[{"tag":"Span","contents":[{"line":350,"column":8},{"line":350,"column":46},{"doc":"assemble col xk xv yk yv zk zv a b c d"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":350,"column":8},{"line":350,"column":44},{"doc":"assemble col xk xv yk yv zk zv a b c"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":350,"column":8},{"line":350,"column":42},{"doc":"assemble col xk xv yk yv zk zv a b"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":350,"column":8},{"line":350,"column":40},{"doc":"assemble col xk xv yk yv zk zv a"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":350,"column":8},{"line":350,"column":38},{"doc":"assemble col xk xv yk yv zk zv"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":350,"column":8},{"line":350,"column":35},{"doc":"assemble col xk xv yk yv zk"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":350,"column":8},{"line":350,"column":32},{"doc":"assemble col xk xv yk yv"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":350,"column":8},{"line":350,"column":29},{"doc":"assemble col xk xv yk"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":350,"column":8},{"line":350,"column":26},{"doc":"assemble col xk xv"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":350,"column":8},{"line":350,"column":23},{"doc":"assemble col xk"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":350,"column":8},{"line":350,"column":20},{"doc":"assemble col"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":350,"column":8},{"line":350,"column":16},{"doc":"assemble"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"assemble"}}],[{"tag":"Span","contents":[{"line":350,"column":17},{"line":350,"column":20},{"doc":"col"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"col"}}]]}],[{"tag":"Span","contents":[{"line":350,"column":21},{"line":350,"column":23},{"doc":"xk"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"xk"}}]]}],[{"tag":"Span","contents":[{"line":350,"column":24},{"line":350,"column":26},{"doc":"xv"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"xv"}}]]}],[{"tag":"Span","contents":[{"line":350,"column":27},{"line":350,"column":29},{"doc":"yk"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"yk"}}]]}],[{"tag":"Span","contents":[{"line":350,"column":30},{"line":350,"column":32},{"doc":"yv"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"yv"}}]]}],[{"tag":"Span","contents":[{"line":350,"column":33},{"line":350,"column":35},{"doc":"zk"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"zk"}}]]}],[{"tag":"Span","contents":[{"line":350,"column":36},{"line":350,"column":38},{"doc":"zv"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"zv"}}]]}],[{"tag":"Span","contents":[{"line":350,"column":39},{"line":350,"column":40},{"doc":"a"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"a"}}]]}],[{"tag":"Span","contents":[{"line":350,"column":41},{"line":350,"column":42},{"doc":"b"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"b"}}]]}],[{"tag":"Span","contents":[{"line":350,"column":43},{"line":350,"column":44},{"doc":"c"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"c"}}]]}],[{"tag":"Span","contents":[{"line":350,"column":45},{"line":350,"column":46},{"doc":"d"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"d"}}]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"BBlack"},[]]},{"tag":"Var","contents":"xk"},{"tag":"Var","contents":"xv"},{"tag":"Var","contents":"a"},{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"NBlack"},[]]},{"tag":"Var","contents":"zk"},{"tag":"Var","contents":"zv"},{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Black"},[]]},{"tag":"Var","contents":"yk"},{"tag":"Var","contents":"yv"},{"tag":"Var","contents":"b"},{"tag":"Var","contents":"c"}]]},{"tag":"Var","contents":"d"}]]}]]},[{"tag":"Span","contents":[{"line":353,"column":8},{"line":358,"column":6},{"doc":"case d of\n  RBNode Black _ _ _ _ -> RBNode\n                            Black\n                            yk\n                            yv\n                            (RBNode Black xk xv a b)\n                            (balance Black zk zv c (redden d))\n  _ -> t"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":353,"column":13},{"line":353,"column":14},{"doc":"d"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"d"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Black"},[]]},{"tag":"Anything","contents":[]},{"tag":"Anything","contents":[]},{"tag":"Anything","contents":[]},{"tag":"Anything","contents":[]}]]},[{"tag":"Span","contents":[{"line":355,"column":12},{"line":355,"column":88},{"doc":"RBNode\n  Black\n  yk\n  yv\n  (RBNode Black xk xv a b)\n  (balance Black zk zv c (redden d))"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":355,"column":12},{"line":355,"column":54},{"doc":"RBNode Black yk yv (RBNode Black xk xv a b)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":355,"column":12},{"line":355,"column":30},{"doc":"RBNode Black yk yv"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":355,"column":12},{"line":355,"column":27},{"doc":"RBNode Black yk"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":355,"column":12},{"line":355,"column":24},{"doc":"RBNode Black"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":355,"column":12},{"line":355,"column":18},{"doc":"RBNode"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBNode"}}],[{"tag":"Span","contents":[{"line":355,"column":19},{"line":355,"column":24},{"doc":"Black"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Black"}}]]}],[{"tag":"Span","contents":[{"line":355,"column":25},{"line":355,"column":27},{"doc":"yk"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"yk"}}]]}],[{"tag":"Span","contents":[{"line":355,"column":28},{"line":355,"column":30},{"doc":"yv"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"yv"}}]]}],[{"tag":"Span","contents":[{"line":355,"column":32},{"line":355,"column":54},{"doc":"RBNode Black xk xv a b"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":355,"column":32},{"line":355,"column":52},{"doc":"RBNode Black xk xv a"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":355,"column":32},{"line":355,"column":50},{"doc":"RBNode Black xk xv"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":355,"column":32},{"line":355,"column":47},{"doc":"RBNode Black xk"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":355,"column":32},{"line":355,"column":44},{"doc":"RBNode Black"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":355,"column":32},{"line":355,"column":38},{"doc":"RBNode"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBNode"}}],[{"tag":"Span","contents":[{"line":355,"column":39},{"line":355,"column":44},{"doc":"Black"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Black"}}]]}],[{"tag":"Span","contents":[{"line":355,"column":45},{"line":355,"column":47},{"doc":"xk"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"xk"}}]]}],[{"tag":"Span","contents":[{"line":355,"column":48},{"line":355,"column":50},{"doc":"xv"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"xv"}}]]}],[{"tag":"Span","contents":[{"line":355,"column":51},{"line":355,"column":52},{"doc":"a"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"a"}}]]}],[{"tag":"Span","contents":[{"line":355,"column":53},{"line":355,"column":54},{"doc":"b"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"b"}}]]}]]}],[{"tag":"Span","contents":[{"line":355,"column":57},{"line":355,"column":88},{"doc":"balance Black zk zv c (redden d)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":355,"column":57},{"line":355,"column":78},{"doc":"balance Black zk zv c"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":355,"column":57},{"line":355,"column":76},{"doc":"balance Black zk zv"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":355,"column":57},{"line":355,"column":73},{"doc":"balance Black zk"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":355,"column":57},{"line":355,"column":70},{"doc":"balance Black"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":355,"column":57},{"line":355,"column":64},{"doc":"balance"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"balance"}}],[{"tag":"Span","contents":[{"line":355,"column":65},{"line":355,"column":70},{"doc":"Black"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Black"}}]]}],[{"tag":"Span","contents":[{"line":355,"column":71},{"line":355,"column":73},{"doc":"zk"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"zk"}}]]}],[{"tag":"Span","contents":[{"line":355,"column":74},{"line":355,"column":76},{"doc":"zv"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"zv"}}]]}],[{"tag":"Span","contents":[{"line":355,"column":77},{"line":355,"column":78},{"doc":"c"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"c"}}]]}],[{"tag":"Span","contents":[{"line":355,"column":80},{"line":355,"column":88},{"doc":"redden d"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":355,"column":80},{"line":355,"column":86},{"doc":"redden"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"redden"}}],[{"tag":"Span","contents":[{"line":355,"column":87},{"line":355,"column":88},{"doc":"d"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"d"}}]]}]]}]]}]],[{"tag":"Anything","contents":[]},[{"tag":"Span","contents":[{"line":356,"column":15},{"line":356,"column":16},{"doc":"t"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"t"}}]]]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"BBlack"},[]]},{"tag":"Var","contents":"zk"},{"tag":"Var","contents":"zv"},{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"NBlack"},[]]},{"tag":"Var","contents":"xk"},{"tag":"Var","contents":"xv"},{"tag":"Var","contents":"a"},{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Black"},[]]},{"tag":"Var","contents":"yk"},{"tag":"Var","contents":"yv"},{"tag":"Var","contents":"b"},{"tag":"Var","contents":"c"}]]}]]},{"tag":"Var","contents":"d"}]]},[{"tag":"Span","contents":[{"line":359,"column":8},{"line":363,"column":6},{"doc":"case a of\n  RBNode Black _ _ _ _ -> RBNode\n                            Black\n                            yk\n                            yv\n                            (balance Black xk xv (redden a) b)\n                            (RBNode Black zk zv c d)\n  _ -> t"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":359,"column":13},{"line":359,"column":14},{"doc":"a"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"a"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Black"},[]]},{"tag":"Anything","contents":[]},{"tag":"Anything","contents":[]},{"tag":"Anything","contents":[]},{"tag":"Anything","contents":[]}]]},[{"tag":"Span","contents":[{"line":361,"column":12},{"line":361,"column":89},{"doc":"RBNode\n  Black\n  yk\n  yv\n  (balance Black xk xv (redden a) b)\n  (RBNode Black zk zv c d)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":361,"column":12},{"line":361,"column":64},{"doc":"RBNode Black yk yv (balance Black xk xv (redden a) b)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":361,"column":12},{"line":361,"column":30},{"doc":"RBNode Black yk yv"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":361,"column":12},{"line":361,"column":27},{"doc":"RBNode Black yk"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":361,"column":12},{"line":361,"column":24},{"doc":"RBNode Black"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":361,"column":12},{"line":361,"column":18},{"doc":"RBNode"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBNode"}}],[{"tag":"Span","contents":[{"line":361,"column":19},{"line":361,"column":24},{"doc":"Black"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Black"}}]]}],[{"tag":"Span","contents":[{"line":361,"column":25},{"line":361,"column":27},{"doc":"yk"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"yk"}}]]}],[{"tag":"Span","contents":[{"line":361,"column":28},{"line":361,"column":30},{"doc":"yv"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"yv"}}]]}],[{"tag":"Span","contents":[{"line":361,"column":32},{"line":361,"column":64},{"doc":"balance Black xk xv (redden a) b"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":361,"column":32},{"line":361,"column":61},{"doc":"balance Black xk xv (redden a)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":361,"column":32},{"line":361,"column":51},{"doc":"balance Black xk xv"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":361,"column":32},{"line":361,"column":48},{"doc":"balance Black xk"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":361,"column":32},{"line":361,"column":45},{"doc":"balance Black"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":361,"column":32},{"line":361,"column":39},{"doc":"balance"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"balance"}}],[{"tag":"Span","contents":[{"line":361,"column":40},{"line":361,"column":45},{"doc":"Black"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Black"}}]]}],[{"tag":"Span","contents":[{"line":361,"column":46},{"line":361,"column":48},{"doc":"xk"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"xk"}}]]}],[{"tag":"Span","contents":[{"line":361,"column":49},{"line":361,"column":51},{"doc":"xv"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"xv"}}]]}],[{"tag":"Span","contents":[{"line":361,"column":53},{"line":361,"column":61},{"doc":"redden a"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":361,"column":53},{"line":361,"column":59},{"doc":"redden"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"redden"}}],[{"tag":"Span","contents":[{"line":361,"column":60},{"line":361,"column":61},{"doc":"a"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"a"}}]]}]]}],[{"tag":"Span","contents":[{"line":361,"column":63},{"line":361,"column":64},{"doc":"b"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"b"}}]]}]]}],[{"tag":"Span","contents":[{"line":361,"column":67},{"line":361,"column":89},{"doc":"RBNode Black zk zv c d"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":361,"column":67},{"line":361,"column":87},{"doc":"RBNode Black zk zv c"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":361,"column":67},{"line":361,"column":85},{"doc":"RBNode Black zk zv"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":361,"column":67},{"line":361,"column":82},{"doc":"RBNode Black zk"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":361,"column":67},{"line":361,"column":79},{"doc":"RBNode Black"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":361,"column":67},{"line":361,"column":73},{"doc":"RBNode"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBNode"}}],[{"tag":"Span","contents":[{"line":361,"column":74},{"line":361,"column":79},{"doc":"Black"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Black"}}]]}],[{"tag":"Span","contents":[{"line":361,"column":80},{"line":361,"column":82},{"doc":"zk"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"zk"}}]]}],[{"tag":"Span","contents":[{"line":361,"column":83},{"line":361,"column":85},{"doc":"zv"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"zv"}}]]}],[{"tag":"Span","contents":[{"line":361,"column":86},{"line":361,"column":87},{"doc":"c"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"c"}}]]}],[{"tag":"Span","contents":[{"line":361,"column":88},{"line":361,"column":89},{"doc":"d"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"d"}}]]}]]}]],[{"tag":"Anything","contents":[]},[{"tag":"Span","contents":[{"line":362,"column":15},{"line":362,"column":16},{"doc":"t"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"t"}}]]]]}]],[{"tag":"Anything","contents":[]},[{"tag":"Span","contents":[{"line":363,"column":11},{"line":363,"column":12},{"doc":"t"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"t"}}]]]]}]],[[{"tag":"Span","contents":[{"line":364,"column":9},{"line":364,"column":10},{"doc":"t"}]},{"tag":"Literal","contents":{"tag":"Boolean","contents":true}}],[{"tag":"Span","contents":[{"line":364,"column":9},{"line":364,"column":10},{"doc":"t"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"t"}}]]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]}],[{"tag":"Var","contents":"balance"},[{"tag":"Span","contents":[{"line":326,"column":5},{"line":326,"column":35},{"doc":"balance_node (RBNode c k v l r)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"c"},[{"tag":"Span","contents":[{"line":326,"column":5},{"line":326,"column":35},{"doc":"balance_node (RBNode c k v l r)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"k"},[{"tag":"Span","contents":[{"line":326,"column":5},{"line":326,"column":35},{"doc":"balance_node (RBNode c k v l r)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"v"},[{"tag":"Span","contents":[{"line":326,"column":5},{"line":326,"column":35},{"doc":"balance_node (RBNode c k v l r)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"l"},[{"tag":"Span","contents":[{"line":326,"column":5},{"line":326,"column":35},{"doc":"balance_node (RBNode c k v l r)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"r"},[{"tag":"Span","contents":[{"line":326,"column":5},{"line":326,"column":35},{"doc":"balance_node (RBNode c k v l r)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":326,"column":5},{"line":326,"column":17},{"doc":"balance_node"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"balance_node"}}],[{"tag":"Span","contents":[{"line":326,"column":19},{"line":326,"column":35},{"doc":"RBNode c k v l r"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":326,"column":19},{"line":326,"column":33},{"doc":"RBNode c k v l"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":326,"column":19},{"line":326,"column":31},{"doc":"RBNode c k v"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":326,"column":19},{"line":326,"column":29},{"doc":"RBNode c k"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":326,"column":19},{"line":326,"column":27},{"doc":"RBNode c"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":326,"column":19},{"line":326,"column":25},{"doc":"RBNode"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBNode"}}],[{"tag":"Span","contents":[{"line":326,"column":26},{"line":326,"column":27},{"doc":"c"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"c"}}]]}],[{"tag":"Span","contents":[{"line":326,"column":28},{"line":326,"column":29},{"doc":"k"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"k"}}]]}],[{"tag":"Span","contents":[{"line":326,"column":30},{"line":326,"column":31},{"doc":"v"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"v"}}]]}],[{"tag":"Span","contents":[{"line":326,"column":32},{"line":326,"column":33},{"doc":"l"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"l"}}]]}],[{"tag":"Span","contents":[{"line":326,"column":34},{"line":326,"column":35},{"doc":"r"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"r"}}]]}]]}]]}]]}]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},{"tag":"Lambda","contents":[{"tag":"Var","contents":"k"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"v"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]}]}]}]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"bubble"},[{"tag":"Span","contents":[{"line":307,"column":5},{"line":309,"column":30},{"doc":"if | (isBBlack l) || (isBBlack r) ->\n       balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n   | True -> RBNode c k v l r"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"c"},[{"tag":"Span","contents":[{"line":307,"column":5},{"line":309,"column":30},{"doc":"if | (isBBlack l) || (isBBlack r) ->\n       balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n   | True -> RBNode c k v l r"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"k"},[{"tag":"Span","contents":[{"line":307,"column":5},{"line":309,"column":30},{"doc":"if | (isBBlack l) || (isBBlack r) ->\n       balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n   | True -> RBNode c k v l r"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"v"},[{"tag":"Span","contents":[{"line":307,"column":5},{"line":309,"column":30},{"doc":"if | (isBBlack l) || (isBBlack r) ->\n       balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n   | True -> RBNode c k v l r"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"l"},[{"tag":"Span","contents":[{"line":307,"column":5},{"line":309,"column":30},{"doc":"if | (isBBlack l) || (isBBlack r) ->\n       balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n   | True -> RBNode c k v l r"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"r"},[{"tag":"Span","contents":[{"line":307,"column":5},{"line":309,"column":30},{"doc":"if | (isBBlack l) || (isBBlack r) ->\n       balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n   | True -> RBNode c k v l r"}]},{"tag":"MultiIf","contents":[[[{"tag":"Span","contents":[{"line":307,"column":8},{"line":307,"column":32},{"doc":"(isBBlack l) || (isBBlack r)"}]},{"tag":"Binop","contents":[{"home":{"tag":"Module","contents":["Basics"]},"name":"||"},[{"tag":"Span","contents":[{"line":307,"column":8},{"line":307,"column":18},{"doc":"isBBlack l"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":307,"column":8},{"line":307,"column":16},{"doc":"isBBlack"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"isBBlack"}}],[{"tag":"Span","contents":[{"line":307,"column":17},{"line":307,"column":18},{"doc":"l"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"l"}}]]}],[{"tag":"Span","contents":[{"line":307,"column":22},{"line":307,"column":32},{"doc":"isBBlack r"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":307,"column":22},{"line":307,"column":30},{"doc":"isBBlack"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"isBBlack"}}],[{"tag":"Span","contents":[{"line":307,"column":31},{"line":307,"column":32},{"doc":"r"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"r"}}]]}]]}],[{"tag":"Span","contents":[{"line":308,"column":14},{"line":308,"column":74},{"doc":"balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":308,"column":14},{"line":308,"column":56},{"doc":"balance (moreBlack c) k v (lessBlackTree l)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":308,"column":14},{"line":308,"column":39},{"doc":"balance (moreBlack c) k v"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":308,"column":14},{"line":308,"column":37},{"doc":"balance (moreBlack c) k"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":308,"column":14},{"line":308,"column":34},{"doc":"balance (moreBlack c)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":308,"column":14},{"line":308,"column":21},{"doc":"balance"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"balance"}}],[{"tag":"Span","contents":[{"line":308,"column":23},{"line":308,"column":34},{"doc":"moreBlack c"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":308,"column":23},{"line":308,"column":32},{"doc":"moreBlack"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"moreBlack"}}],[{"tag":"Span","contents":[{"line":308,"column":33},{"line":308,"column":34},{"doc":"c"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"c"}}]]}]]}],[{"tag":"Span","contents":[{"line":308,"column":36},{"line":308,"column":37},{"doc":"k"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"k"}}]]}],[{"tag":"Span","contents":[{"line":308,"column":38},{"line":308,"column":39},{"doc":"v"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"v"}}]]}],[{"tag":"Span","contents":[{"line":308,"column":41},{"line":308,"column":56},{"doc":"lessBlackTree l"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":308,"column":41},{"line":308,"column":54},{"doc":"lessBlackTree"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"lessBlackTree"}}],[{"tag":"Span","contents":[{"line":308,"column":55},{"line":308,"column":56},{"doc":"l"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"l"}}]]}]]}],[{"tag":"Span","contents":[{"line":308,"column":59},{"line":308,"column":74},{"doc":"lessBlackTree r"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":308,"column":59},{"line":308,"column":72},{"doc":"lessBlackTree"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"lessBlackTree"}}],[{"tag":"Span","contents":[{"line":308,"column":73},{"line":308,"column":74},{"doc":"r"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"r"}}]]}]]}]],[[{"tag":"Span","contents":[{"line":309,"column":14},{"line":309,"column":30},{"doc":"RBNode c k v l r"}]},{"tag":"Literal","contents":{"tag":"Boolean","contents":true}}],[{"tag":"Span","contents":[{"line":309,"column":14},{"line":309,"column":30},{"doc":"RBNode c k v l r"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":309,"column":14},{"line":309,"column":28},{"doc":"RBNode c k v l"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":309,"column":14},{"line":309,"column":26},{"doc":"RBNode c k v"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":309,"column":14},{"line":309,"column":24},{"doc":"RBNode c k"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":309,"column":14},{"line":309,"column":22},{"doc":"RBNode c"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":309,"column":14},{"line":309,"column":20},{"doc":"RBNode"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBNode"}}],[{"tag":"Span","contents":[{"line":309,"column":21},{"line":309,"column":22},{"doc":"c"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"c"}}]]}],[{"tag":"Span","contents":[{"line":309,"column":23},{"line":309,"column":24},{"doc":"k"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"k"}}]]}],[{"tag":"Span","contents":[{"line":309,"column":25},{"line":309,"column":26},{"doc":"v"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"v"}}]]}],[{"tag":"Span","contents":[{"line":309,"column":27},{"line":309,"column":28},{"doc":"l"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"l"}}]]}],[{"tag":"Span","contents":[{"line":309,"column":29},{"line":309,"column":30},{"doc":"r"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"r"}}]]}]]]}]]}]]}]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},{"tag":"Lambda","contents":[{"tag":"Var","contents":"k"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"v"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]}]}]}]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"remove_max"},[{"tag":"Span","contents":[{"line":315,"column":5},{"line":320,"column":53},{"doc":"case r of\n  RBEmpty _ -> rem c l r\n  RBNode cr kr vr lr rr -> bubble c k v l (remove_max cr kr vr lr rr)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"c"},[{"tag":"Span","contents":[{"line":315,"column":5},{"line":320,"column":53},{"doc":"case r of\n  RBEmpty _ -> rem c l r\n  RBNode cr kr vr lr rr -> bubble c k v l (remove_max cr kr vr lr rr)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"k"},[{"tag":"Span","contents":[{"line":315,"column":5},{"line":320,"column":53},{"doc":"case r of\n  RBEmpty _ -> rem c l r\n  RBNode cr kr vr lr rr -> bubble c k v l (remove_max cr kr vr lr rr)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"v"},[{"tag":"Span","contents":[{"line":315,"column":5},{"line":320,"column":53},{"doc":"case r of\n  RBEmpty _ -> rem c l r\n  RBNode cr kr vr lr rr -> bubble c k v l (remove_max cr kr vr lr rr)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"l"},[{"tag":"Span","contents":[{"line":315,"column":5},{"line":320,"column":53},{"doc":"case r of\n  RBEmpty _ -> rem c l r\n  RBNode cr kr vr lr rr -> bubble c k v l (remove_max cr kr vr lr rr)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"r"},[{"tag":"Span","contents":[{"line":315,"column":5},{"line":320,"column":53},{"doc":"case r of\n  RBEmpty _ -> rem c l r\n  RBNode cr kr vr lr rr -> bubble c k v l (remove_max cr kr vr lr rr)"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":315,"column":10},{"line":315,"column":11},{"doc":"r"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"r"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBEmpty"},[{"tag":"Anything","contents":[]}]]},[{"tag":"Span","contents":[{"line":317,"column":11},{"line":317,"column":20},{"doc":"rem c l r"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":317,"column":11},{"line":317,"column":18},{"doc":"rem c l"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":317,"column":11},{"line":317,"column":16},{"doc":"rem c"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":317,"column":11},{"line":317,"column":14},{"doc":"rem"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"rem"}}],[{"tag":"Span","contents":[{"line":317,"column":15},{"line":317,"column":16},{"doc":"c"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"c"}}]]}],[{"tag":"Span","contents":[{"line":317,"column":17},{"line":317,"column":18},{"doc":"l"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"l"}}]]}],[{"tag":"Span","contents":[{"line":317,"column":19},{"line":317,"column":20},{"doc":"r"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"r"}}]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Var","contents":"cr"},{"tag":"Var","contents":"kr"},{"tag":"Var","contents":"vr"},{"tag":"Var","contents":"lr"},{"tag":"Var","contents":"rr"}]]},[{"tag":"Span","contents":[{"line":320,"column":11},{"line":320,"column":52},{"doc":"bubble c k v l (remove_max cr kr vr lr rr)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":320,"column":11},{"line":320,"column":25},{"doc":"bubble c k v l"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":320,"column":11},{"line":320,"column":23},{"doc":"bubble c k v"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":320,"column":11},{"line":320,"column":21},{"doc":"bubble c k"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":320,"column":11},{"line":320,"column":19},{"doc":"bubble c"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":320,"column":11},{"line":320,"column":17},{"doc":"bubble"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"bubble"}}],[{"tag":"Span","contents":[{"line":320,"column":18},{"line":320,"column":19},{"doc":"c"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"c"}}]]}],[{"tag":"Span","contents":[{"line":320,"column":20},{"line":320,"column":21},{"doc":"k"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"k"}}]]}],[{"tag":"Span","contents":[{"line":320,"column":22},{"line":320,"column":23},{"doc":"v"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"v"}}]]}],[{"tag":"Span","contents":[{"line":320,"column":24},{"line":320,"column":25},{"doc":"l"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"l"}}]]}],[{"tag":"Span","contents":[{"line":320,"column":27},{"line":320,"column":52},{"doc":"remove_max cr kr vr lr rr"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":320,"column":27},{"line":320,"column":49},{"doc":"remove_max cr kr vr lr"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":320,"column":27},{"line":320,"column":46},{"doc":"remove_max cr kr vr"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":320,"column":27},{"line":320,"column":43},{"doc":"remove_max cr kr"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":320,"column":27},{"line":320,"column":40},{"doc":"remove_max cr"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":320,"column":27},{"line":320,"column":37},{"doc":"remove_max"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"remove_max"}}],[{"tag":"Span","contents":[{"line":320,"column":38},{"line":320,"column":40},{"doc":"cr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"cr"}}]]}],[{"tag":"Span","contents":[{"line":320,"column":41},{"line":320,"column":43},{"doc":"kr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"kr"}}]]}],[{"tag":"Span","contents":[{"line":320,"column":44},{"line":320,"column":46},{"doc":"vr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"vr"}}]]}],[{"tag":"Span","contents":[{"line":320,"column":47},{"line":320,"column":49},{"doc":"lr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"lr"}}]]}],[{"tag":"Span","contents":[{"line":320,"column":50},{"line":320,"column":52},{"doc":"rr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"rr"}}]]}]]}]]]]}]]}]]}]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},{"tag":"Lambda","contents":[{"tag":"Var","contents":"k"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"v"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]}]}]}]}]}],[{"tag":"Var","contents":"rem"},[{"tag":"Span","contents":[{"line":272,"column":5},{"line":301,"column":32},{"doc":"case (l,r) of\n  (RBEmpty _,RBEmpty _) -> case c of\n                             Red -> RBEmpty LBlack\n                             Black -> RBEmpty LBBlack\n  (RBEmpty cl,RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                          (Black,LBlack,Red) -> RBNode Black k' v' l' r'\n                                          _ -> reportRemBug\n                                                 \"Black/LBlack/Red\"\n                                                 c\n                                                 (showLColor cl)\n                                                 (showNColor cr)\n  (RBNode cl k' v' l' r',RBEmpty cr) -> case (c,cl,cr) of\n                                          (Black,Red,LBlack) -> RBNode Black k' v' l' r'\n                                          _ -> reportRemBug\n                                                 \"Black/Red/LBlack\"\n                                                 c\n                                                 (showNColor cl)\n                                                 (showLColor cr)\n  (RBNode cl kl vl ll rl,RBNode cr kr vr lr rr) -> let l = RBNode\n                                                             cl kl vl ll rl\n                                                       r = RBNode cr kr vr lr rr\n                                                       (k,v) = max l\n                                                       l' = remove_max cl kl vl ll rl\n                                                   in bubble c k v l' r"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"c"},[{"tag":"Span","contents":[{"line":272,"column":5},{"line":301,"column":32},{"doc":"case (l,r) of\n  (RBEmpty _,RBEmpty _) -> case c of\n                             Red -> RBEmpty LBlack\n                             Black -> RBEmpty LBBlack\n  (RBEmpty cl,RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                          (Black,LBlack,Red) -> RBNode Black k' v' l' r'\n                                          _ -> reportRemBug\n                                                 \"Black/LBlack/Red\"\n                                                 c\n                                                 (showLColor cl)\n                                                 (showNColor cr)\n  (RBNode cl k' v' l' r',RBEmpty cr) -> case (c,cl,cr) of\n                                          (Black,Red,LBlack) -> RBNode Black k' v' l' r'\n                                          _ -> reportRemBug\n                                                 \"Black/Red/LBlack\"\n                                                 c\n                                                 (showNColor cl)\n                                                 (showLColor cr)\n  (RBNode cl kl vl ll rl,RBNode cr kr vr lr rr) -> let l = RBNode\n                                                             cl kl vl ll rl\n                                                       r = RBNode cr kr vr lr rr\n                                                       (k,v) = max l\n                                                       l' = remove_max cl kl vl ll rl\n                                                   in bubble c k v l' r"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"l"},[{"tag":"Span","contents":[{"line":272,"column":5},{"line":301,"column":32},{"doc":"case (l,r) of\n  (RBEmpty _,RBEmpty _) -> case c of\n                             Red -> RBEmpty LBlack\n                             Black -> RBEmpty LBBlack\n  (RBEmpty cl,RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                          (Black,LBlack,Red) -> RBNode Black k' v' l' r'\n                                          _ -> reportRemBug\n                                                 \"Black/LBlack/Red\"\n                                                 c\n                                                 (showLColor cl)\n                                                 (showNColor cr)\n  (RBNode cl k' v' l' r',RBEmpty cr) -> case (c,cl,cr) of\n                                          (Black,Red,LBlack) -> RBNode Black k' v' l' r'\n                                          _ -> reportRemBug\n                                                 \"Black/Red/LBlack\"\n                                                 c\n                                                 (showNColor cl)\n                                                 (showLColor cr)\n  (RBNode cl kl vl ll rl,RBNode cr kr vr lr rr) -> let l = RBNode\n                                                             cl kl vl ll rl\n                                                       r = RBNode cr kr vr lr rr\n                                                       (k,v) = max l\n                                                       l' = remove_max cl kl vl ll rl\n                                                   in bubble c k v l' r"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"r"},[{"tag":"Span","contents":[{"line":272,"column":5},{"line":301,"column":32},{"doc":"case (l,r) of\n  (RBEmpty _,RBEmpty _) -> case c of\n                             Red -> RBEmpty LBlack\n                             Black -> RBEmpty LBBlack\n  (RBEmpty cl,RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                          (Black,LBlack,Red) -> RBNode Black k' v' l' r'\n                                          _ -> reportRemBug\n                                                 \"Black/LBlack/Red\"\n                                                 c\n                                                 (showLColor cl)\n                                                 (showNColor cr)\n  (RBNode cl k' v' l' r',RBEmpty cr) -> case (c,cl,cr) of\n                                          (Black,Red,LBlack) -> RBNode Black k' v' l' r'\n                                          _ -> reportRemBug\n                                                 \"Black/Red/LBlack\"\n                                                 c\n                                                 (showNColor cl)\n                                                 (showLColor cr)\n  (RBNode cl kl vl ll rl,RBNode cr kr vr lr rr) -> let l = RBNode\n                                                             cl kl vl ll rl\n                                                       r = RBNode cr kr vr lr rr\n                                                       (k,v) = max l\n                                                       l' = remove_max cl kl vl ll rl\n                                                   in bubble c k v l' r"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":272,"column":11},{"line":272,"column":15},{"doc":"(l,r)"}]},{"tag":"Data","contents":["_Tuple2",[[{"tag":"Span","contents":[{"line":272,"column":11},{"line":272,"column":12},{"doc":"l"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"l"}}],[{"tag":"Span","contents":[{"line":272,"column":14},{"line":272,"column":15},{"doc":"r"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"r"}}]]]}],[[{"tag":"Data","contents":[{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBEmpty"},[{"tag":"Anything","contents":[]}]]},{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBEmpty"},[{"tag":"Anything","contents":[]}]]}]]},[{"tag":"Span","contents":[{"line":274,"column":11},{"line":278,"column":7},{"doc":"case c of\n  Red -> RBEmpty LBlack\n  Black -> RBEmpty LBBlack"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":274,"column":16},{"line":274,"column":17},{"doc":"c"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"c"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Red"},[]]},[{"tag":"Span","contents":[{"line":275,"column":22},{"line":275,"column":36},{"doc":"RBEmpty LBlack"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":275,"column":22},{"line":275,"column":29},{"doc":"RBEmpty"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBEmpty"}}],[{"tag":"Span","contents":[{"line":275,"column":30},{"line":275,"column":36},{"doc":"LBlack"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"LBlack"}}]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Black"},[]]},[{"tag":"Span","contents":[{"line":276,"column":22},{"line":276,"column":37},{"doc":"RBEmpty LBBlack"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":276,"column":22},{"line":276,"column":29},{"doc":"RBEmpty"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBEmpty"}}],[{"tag":"Span","contents":[{"line":276,"column":30},{"line":276,"column":37},{"doc":"LBBlack"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"LBBlack"}}]]}]]]]}]],[{"tag":"Data","contents":[{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBEmpty"},[{"tag":"Var","contents":"cl"}]]},{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Var","contents":"cr"},{"tag":"Var","contents":"k'"},{"tag":"Var","contents":"v'"},{"tag":"Var","contents":"l'"},{"tag":"Var","contents":"r'"}]]}]]},[{"tag":"Span","contents":[{"line":279,"column":11},{"line":286,"column":7},{"doc":"case (c,cl,cr) of\n  (Black,LBlack,Red) -> RBNode Black k' v' l' r'\n  _ -> reportRemBug\n         \"Black/LBlack/Red\" c (showLColor cl) (showNColor cr)"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":279,"column":17},{"line":279,"column":26},{"doc":"(c,cl,cr)"}]},{"tag":"Data","contents":["_Tuple3",[[{"tag":"Span","contents":[{"line":279,"column":17},{"line":279,"column":18},{"doc":"c"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"c"}}],[{"tag":"Span","contents":[{"line":279,"column":20},{"line":279,"column":22},{"doc":"cl"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"cl"}}],[{"tag":"Span","contents":[{"line":279,"column":24},{"line":279,"column":26},{"doc":"cr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"cr"}}]]]}],[[{"tag":"Data","contents":[{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple3"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Black"},[]]},{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"LBlack"},[]]},{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Red"},[]]}]]},[{"tag":"Span","contents":[{"line":281,"column":17},{"line":281,"column":41},{"doc":"RBNode Black k' v' l' r'"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":281,"column":17},{"line":281,"column":38},{"doc":"RBNode Black k' v' l'"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":281,"column":17},{"line":281,"column":35},{"doc":"RBNode Black k' v'"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":281,"column":17},{"line":281,"column":32},{"doc":"RBNode Black k'"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":281,"column":17},{"line":281,"column":29},{"doc":"RBNode Black"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":281,"column":17},{"line":281,"column":23},{"doc":"RBNode"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBNode"}}],[{"tag":"Span","contents":[{"line":281,"column":24},{"line":281,"column":29},{"doc":"Black"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Black"}}]]}],[{"tag":"Span","contents":[{"line":281,"column":30},{"line":281,"column":32},{"doc":"k'"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"k'"}}]]}],[{"tag":"Span","contents":[{"line":281,"column":33},{"line":281,"column":35},{"doc":"v'"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"v'"}}]]}],[{"tag":"Span","contents":[{"line":281,"column":36},{"line":281,"column":38},{"doc":"l'"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"l'"}}]]}],[{"tag":"Span","contents":[{"line":281,"column":39},{"line":281,"column":41},{"doc":"r'"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"r'"}}]]}]],[{"tag":"Anything","contents":[]},[{"tag":"Span","contents":[{"line":284,"column":17},{"line":284,"column":81},{"doc":"reportRemBug \"Black/LBlack/Red\" c (showLColor cl) (showNColor cr)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":284,"column":17},{"line":284,"column":65},{"doc":"reportRemBug \"Black/LBlack/Red\" c (showLColor cl)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":284,"column":17},{"line":284,"column":50},{"doc":"reportRemBug \"Black/LBlack/Red\" c"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":284,"column":17},{"line":284,"column":48},{"doc":"reportRemBug \"Black/LBlack/Red\""}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":284,"column":17},{"line":284,"column":29},{"doc":"reportRemBug"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"reportRemBug"}}],[{"tag":"Span","contents":[{"line":284,"column":30},{"line":284,"column":48},{"doc":"\"Black/LBlack/Red\""}]},{"tag":"Literal","contents":{"tag":"Str","contents":"Black/LBlack/Red"}}]]}],[{"tag":"Span","contents":[{"line":284,"column":49},{"line":284,"column":50},{"doc":"c"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"c"}}]]}],[{"tag":"Span","contents":[{"line":284,"column":52},{"line":284,"column":65},{"doc":"showLColor cl"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":284,"column":52},{"line":284,"column":62},{"doc":"showLColor"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"showLColor"}}],[{"tag":"Span","contents":[{"line":284,"column":63},{"line":284,"column":65},{"doc":"cl"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"cl"}}]]}]]}],[{"tag":"Span","contents":[{"line":284,"column":68},{"line":284,"column":81},{"doc":"showNColor cr"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":284,"column":68},{"line":284,"column":78},{"doc":"showNColor"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"showNColor"}}],[{"tag":"Span","contents":[{"line":284,"column":79},{"line":284,"column":81},{"doc":"cr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"cr"}}]]}]]}]]]]}]],[{"tag":"Data","contents":[{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Var","contents":"cl"},{"tag":"Var","contents":"k'"},{"tag":"Var","contents":"v'"},{"tag":"Var","contents":"l'"},{"tag":"Var","contents":"r'"}]]},{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBEmpty"},[{"tag":"Var","contents":"cr"}]]}]]},[{"tag":"Span","contents":[{"line":287,"column":11},{"line":295,"column":7},{"doc":"case (c,cl,cr) of\n  (Black,Red,LBlack) -> RBNode Black k' v' l' r'\n  _ -> reportRemBug\n         \"Black/Red/LBlack\" c (showNColor cl) (showLColor cr)"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":287,"column":17},{"line":287,"column":26},{"doc":"(c,cl,cr)"}]},{"tag":"Data","contents":["_Tuple3",[[{"tag":"Span","contents":[{"line":287,"column":17},{"line":287,"column":18},{"doc":"c"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"c"}}],[{"tag":"Span","contents":[{"line":287,"column":20},{"line":287,"column":22},{"doc":"cl"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"cl"}}],[{"tag":"Span","contents":[{"line":287,"column":24},{"line":287,"column":26},{"doc":"cr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"cr"}}]]]}],[[{"tag":"Data","contents":[{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple3"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Black"},[]]},{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Red"},[]]},{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"LBlack"},[]]}]]},[{"tag":"Span","contents":[{"line":289,"column":17},{"line":289,"column":41},{"doc":"RBNode Black k' v' l' r'"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":289,"column":17},{"line":289,"column":38},{"doc":"RBNode Black k' v' l'"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":289,"column":17},{"line":289,"column":35},{"doc":"RBNode Black k' v'"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":289,"column":17},{"line":289,"column":32},{"doc":"RBNode Black k'"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":289,"column":17},{"line":289,"column":29},{"doc":"RBNode Black"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":289,"column":17},{"line":289,"column":23},{"doc":"RBNode"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBNode"}}],[{"tag":"Span","contents":[{"line":289,"column":24},{"line":289,"column":29},{"doc":"Black"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Black"}}]]}],[{"tag":"Span","contents":[{"line":289,"column":30},{"line":289,"column":32},{"doc":"k'"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"k'"}}]]}],[{"tag":"Span","contents":[{"line":289,"column":33},{"line":289,"column":35},{"doc":"v'"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"v'"}}]]}],[{"tag":"Span","contents":[{"line":289,"column":36},{"line":289,"column":38},{"doc":"l'"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"l'"}}]]}],[{"tag":"Span","contents":[{"line":289,"column":39},{"line":289,"column":41},{"doc":"r'"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"r'"}}]]}]],[{"tag":"Anything","contents":[]},[{"tag":"Span","contents":[{"line":292,"column":17},{"line":292,"column":81},{"doc":"reportRemBug \"Black/Red/LBlack\" c (showNColor cl) (showLColor cr)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":292,"column":17},{"line":292,"column":65},{"doc":"reportRemBug \"Black/Red/LBlack\" c (showNColor cl)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":292,"column":17},{"line":292,"column":50},{"doc":"reportRemBug \"Black/Red/LBlack\" c"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":292,"column":17},{"line":292,"column":48},{"doc":"reportRemBug \"Black/Red/LBlack\""}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":292,"column":17},{"line":292,"column":29},{"doc":"reportRemBug"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"reportRemBug"}}],[{"tag":"Span","contents":[{"line":292,"column":30},{"line":292,"column":48},{"doc":"\"Black/Red/LBlack\""}]},{"tag":"Literal","contents":{"tag":"Str","contents":"Black/Red/LBlack"}}]]}],[{"tag":"Span","contents":[{"line":292,"column":49},{"line":292,"column":50},{"doc":"c"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"c"}}]]}],[{"tag":"Span","contents":[{"line":292,"column":52},{"line":292,"column":65},{"doc":"showNColor cl"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":292,"column":52},{"line":292,"column":62},{"doc":"showNColor"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"showNColor"}}],[{"tag":"Span","contents":[{"line":292,"column":63},{"line":292,"column":65},{"doc":"cl"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"cl"}}]]}]]}],[{"tag":"Span","contents":[{"line":292,"column":68},{"line":292,"column":81},{"doc":"showLColor cr"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":292,"column":68},{"line":292,"column":78},{"doc":"showLColor"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"showLColor"}}],[{"tag":"Span","contents":[{"line":292,"column":79},{"line":292,"column":81},{"doc":"cr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"cr"}}]]}]]}]]]]}]],[{"tag":"Data","contents":[{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Var","contents":"cl"},{"tag":"Var","contents":"kl"},{"tag":"Var","contents":"vl"},{"tag":"Var","contents":"ll"},{"tag":"Var","contents":"rl"}]]},{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Var","contents":"cr"},{"tag":"Var","contents":"kr"},{"tag":"Var","contents":"vr"},{"tag":"Var","contents":"lr"},{"tag":"Var","contents":"rr"}]]}]]},[{"tag":"Span","contents":[{"line":296,"column":11},{"line":301,"column":32},{"doc":"let l = RBNode cl kl vl ll rl\n    r = RBNode cr kr vr lr rr\n    (k,v) = max l\n    l' = remove_max cl kl vl ll rl\nin bubble c k v l' r"}]},{"tag":"Let","contents":[[[{"tag":"Var","contents":"l'"},[{"tag":"Span","contents":[{"line":299,"column":24},{"line":299,"column":49},{"doc":"remove_max cl kl vl ll rl"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":299,"column":24},{"line":299,"column":46},{"doc":"remove_max cl kl vl ll"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":299,"column":24},{"line":299,"column":43},{"doc":"remove_max cl kl vl"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":299,"column":24},{"line":299,"column":40},{"doc":"remove_max cl kl"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":299,"column":24},{"line":299,"column":37},{"doc":"remove_max cl"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":299,"column":24},{"line":299,"column":34},{"doc":"remove_max"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"remove_max"}}],[{"tag":"Span","contents":[{"line":299,"column":35},{"line":299,"column":37},{"doc":"cl"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"cl"}}]]}],[{"tag":"Span","contents":[{"line":299,"column":38},{"line":299,"column":40},{"doc":"kl"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"kl"}}]]}],[{"tag":"Span","contents":[{"line":299,"column":41},{"line":299,"column":43},{"doc":"vl"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"vl"}}]]}],[{"tag":"Span","contents":[{"line":299,"column":44},{"line":299,"column":46},{"doc":"ll"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"ll"}}]]}],[{"tag":"Span","contents":[{"line":299,"column":47},{"line":299,"column":49},{"doc":"rl"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"rl"}}]]}],null]],[{"tag":"Span","contents":[{"line":296,"column":11},{"line":301,"column":32},{"doc":"let l = RBNode cl kl vl ll rl\n    r = RBNode cr kr vr lr rr\n    (k,v) = max l\n    l' = remove_max cl kl vl ll rl\nin bubble c k v l' r"}]},{"tag":"Let","contents":[[[{"tag":"Var","contents":"r"},[{"tag":"Span","contents":[{"line":297,"column":19},{"line":297,"column":40},{"doc":"RBNode cr kr vr lr rr"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":297,"column":19},{"line":297,"column":37},{"doc":"RBNode cr kr vr lr"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":297,"column":19},{"line":297,"column":34},{"doc":"RBNode cr kr vr"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":297,"column":19},{"line":297,"column":31},{"doc":"RBNode cr kr"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":297,"column":19},{"line":297,"column":28},{"doc":"RBNode cr"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":297,"column":19},{"line":297,"column":25},{"doc":"RBNode"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBNode"}}],[{"tag":"Span","contents":[{"line":297,"column":26},{"line":297,"column":28},{"doc":"cr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"cr"}}]]}],[{"tag":"Span","contents":[{"line":297,"column":29},{"line":297,"column":31},{"doc":"kr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"kr"}}]]}],[{"tag":"Span","contents":[{"line":297,"column":32},{"line":297,"column":34},{"doc":"vr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"vr"}}]]}],[{"tag":"Span","contents":[{"line":297,"column":35},{"line":297,"column":37},{"doc":"lr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"lr"}}]]}],[{"tag":"Span","contents":[{"line":297,"column":38},{"line":297,"column":40},{"doc":"rr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"rr"}}]]}],null]],[{"tag":"Span","contents":[{"line":296,"column":11},{"line":301,"column":32},{"doc":"let l = RBNode cl kl vl ll rl\n    r = RBNode cr kr vr lr rr\n    (k,v) = max l\n    l' = remove_max cl kl vl ll rl\nin bubble c k v l' r"}]},{"tag":"Let","contents":[[[{"tag":"Var","contents":"l"},[{"tag":"Span","contents":[{"line":296,"column":19},{"line":296,"column":40},{"doc":"RBNode cl kl vl ll rl"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":296,"column":19},{"line":296,"column":37},{"doc":"RBNode cl kl vl ll"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":296,"column":19},{"line":296,"column":34},{"doc":"RBNode cl kl vl"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":296,"column":19},{"line":296,"column":31},{"doc":"RBNode cl kl"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":296,"column":19},{"line":296,"column":28},{"doc":"RBNode cl"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":296,"column":19},{"line":296,"column":25},{"doc":"RBNode"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBNode"}}],[{"tag":"Span","contents":[{"line":296,"column":26},{"line":296,"column":28},{"doc":"cl"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"cl"}}]]}],[{"tag":"Span","contents":[{"line":296,"column":29},{"line":296,"column":31},{"doc":"kl"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"kl"}}]]}],[{"tag":"Span","contents":[{"line":296,"column":32},{"line":296,"column":34},{"doc":"vl"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"vl"}}]]}],[{"tag":"Span","contents":[{"line":296,"column":35},{"line":296,"column":37},{"doc":"ll"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"ll"}}]]}],[{"tag":"Span","contents":[{"line":296,"column":38},{"line":296,"column":40},{"doc":"rl"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"rl"}}]]}],null]],[{"tag":"Span","contents":[{"line":296,"column":11},{"line":301,"column":32},{"doc":"let l = RBNode cl kl vl ll rl\n    r = RBNode cr kr vr lr rr\n    (k,v) = max l\n    l' = remove_max cl kl vl ll rl\nin bubble c k v l' r"}]},{"tag":"Let","contents":[[[{"tag":"Data","contents":[{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},[{"tag":"Span","contents":[{"line":298,"column":24},{"line":298,"column":29},{"doc":"max l"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":298,"column":24},{"line":298,"column":27},{"doc":"max"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"max"}}],[{"tag":"Span","contents":[{"line":298,"column":28},{"line":298,"column":29},{"doc":"l"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"l"}}]]}],null]],[{"tag":"Span","contents":[{"line":301,"column":15},{"line":301,"column":32},{"doc":"bubble c k v l' r"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":301,"column":15},{"line":301,"column":30},{"doc":"bubble c k v l'"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":301,"column":15},{"line":301,"column":27},{"doc":"bubble c k v"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":301,"column":15},{"line":301,"column":25},{"doc":"bubble c k"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":301,"column":15},{"line":301,"column":23},{"doc":"bubble c"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":301,"column":15},{"line":301,"column":21},{"doc":"bubble"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"bubble"}}],[{"tag":"Span","contents":[{"line":301,"column":22},{"line":301,"column":23},{"doc":"c"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"c"}}]]}],[{"tag":"Span","contents":[{"line":301,"column":24},{"line":301,"column":25},{"doc":"k"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"k"}}]]}],[{"tag":"Span","contents":[{"line":301,"column":26},{"line":301,"column":27},{"doc":"v"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"v"}}]]}],[{"tag":"Span","contents":[{"line":301,"column":28},{"line":301,"column":30},{"doc":"l'"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"l'"}}]]}],[{"tag":"Span","contents":[{"line":301,"column":31},{"line":301,"column":32},{"doc":"r"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"r"}}]]}]]}]]}]]}]]}]]]]}]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"NColor"}},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"k"},{"tag":"Var","contents":"v"}]]}]}]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"update"},[{"tag":"Span","contents":[{"line":183,"column":3},{"line":220,"column":52},{"doc":"let up = \\dict -> case dict of\n                    RBEmpty LBlack -> case alter Nothing of\n                                        Nothing -> (Same,empty)\n                                        Just v -> (Insert,RBNode Red k v empty empty)\n                    RBNode clr key value left right -> case compare k key of\n                                                         EQ -> case alter (Just value) of\n                                                                 Nothing -> (Remove,\n                                                                             rem clr left right)\n                                                                 Just newValue -> (Same,\n                                                                                   RBNode\n                                                                                     clr\n                                                                                     key\n                                                                                     newValue\n                                                                                     left\n                                                                                     right)\n                                                         LT -> let (flag,newLeft) = up left\n                                                               in case flag of\n                                                                    Same -> (Same,\n                                                                             RBNode\n                                                                               clr\n                                                                               key\n                                                                               value\n                                                                               newLeft\n                                                                               right)\n                                                                    Insert -> (Insert,\n                                                                               balance\n                                                                                 clr\n                                                                                 key\n                                                                                 value\n                                                                                 newLeft\n                                                                                 right)\n                                                                    Remove -> (Remove,\n                                                                               bubble\n                                                                                 clr\n                                                                                 key\n                                                                                 value\n                                                                                 newLeft\n                                                                                 right)\n                                                         GT -> let (flag,newRight) = up right\n                                                               in case flag of\n                                                                    Same -> (Same,\n                                                                             RBNode\n                                                                               clr\n                                                                               key\n                                                                               value\n                                                                               left\n                                                                               newRight)\n                                                                    Insert -> (Insert,\n                                                                               balance\n                                                                                 clr\n                                                                                 key\n                                                                                 value\n                                                                                 left\n                                                                                 newRight)\n                                                                    Remove -> (Remove,\n                                                                               bubble\n                                                                                 clr\n                                                                                 key\n                                                                                 value\n                                                                                 left\n                                                                                 newRight)\n    (flag,updatedDict) = up dict\nin case flag of\n     Same -> updatedDict\n     Insert -> ensureBlackRoot updatedDict\n     Remove -> blacken updatedDict"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"k"},[{"tag":"Span","contents":[{"line":183,"column":3},{"line":220,"column":52},{"doc":"let up = \\dict -> case dict of\n                    RBEmpty LBlack -> case alter Nothing of\n                                        Nothing -> (Same,empty)\n                                        Just v -> (Insert,RBNode Red k v empty empty)\n                    RBNode clr key value left right -> case compare k key of\n                                                         EQ -> case alter (Just value) of\n                                                                 Nothing -> (Remove,\n                                                                             rem clr left right)\n                                                                 Just newValue -> (Same,\n                                                                                   RBNode\n                                                                                     clr\n                                                                                     key\n                                                                                     newValue\n                                                                                     left\n                                                                                     right)\n                                                         LT -> let (flag,newLeft) = up left\n                                                               in case flag of\n                                                                    Same -> (Same,\n                                                                             RBNode\n                                                                               clr\n                                                                               key\n                                                                               value\n                                                                               newLeft\n                                                                               right)\n                                                                    Insert -> (Insert,\n                                                                               balance\n                                                                                 clr\n                                                                                 key\n                                                                                 value\n                                                                                 newLeft\n                                                                                 right)\n                                                                    Remove -> (Remove,\n                                                                               bubble\n                                                                                 clr\n                                                                                 key\n                                                                                 value\n                                                                                 newLeft\n                                                                                 right)\n                                                         GT -> let (flag,newRight) = up right\n                                                               in case flag of\n                                                                    Same -> (Same,\n                                                                             RBNode\n                                                                               clr\n                                                                               key\n                                                                               value\n                                                                               left\n                                                                               newRight)\n                                                                    Insert -> (Insert,\n                                                                               balance\n                                                                                 clr\n                                                                                 key\n                                                                                 value\n                                                                                 left\n                                                                                 newRight)\n                                                                    Remove -> (Remove,\n                                                                               bubble\n                                                                                 clr\n                                                                                 key\n                                                                                 value\n                                                                                 left\n                                                                                 newRight)\n    (flag,updatedDict) = up dict\nin case flag of\n     Same -> updatedDict\n     Insert -> ensureBlackRoot updatedDict\n     Remove -> blacken updatedDict"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"alter"},[{"tag":"Span","contents":[{"line":183,"column":3},{"line":220,"column":52},{"doc":"let up = \\dict -> case dict of\n                    RBEmpty LBlack -> case alter Nothing of\n                                        Nothing -> (Same,empty)\n                                        Just v -> (Insert,RBNode Red k v empty empty)\n                    RBNode clr key value left right -> case compare k key of\n                                                         EQ -> case alter (Just value) of\n                                                                 Nothing -> (Remove,\n                                                                             rem clr left right)\n                                                                 Just newValue -> (Same,\n                                                                                   RBNode\n                                                                                     clr\n                                                                                     key\n                                                                                     newValue\n                                                                                     left\n                                                                                     right)\n                                                         LT -> let (flag,newLeft) = up left\n                                                               in case flag of\n                                                                    Same -> (Same,\n                                                                             RBNode\n                                                                               clr\n                                                                               key\n                                                                               value\n                                                                               newLeft\n                                                                               right)\n                                                                    Insert -> (Insert,\n                                                                               balance\n                                                                                 clr\n                                                                                 key\n                                                                                 value\n                                                                                 newLeft\n                                                                                 right)\n                                                                    Remove -> (Remove,\n                                                                               bubble\n                                                                                 clr\n                                                                                 key\n                                                                                 value\n                                                                                 newLeft\n                                                                                 right)\n                                                         GT -> let (flag,newRight) = up right\n                                                               in case flag of\n                                                                    Same -> (Same,\n                                                                             RBNode\n                                                                               clr\n                                                                               key\n                                                                               value\n                                                                               left\n                                                                               newRight)\n                                                                    Insert -> (Insert,\n                                                                               balance\n                                                                                 clr\n                                                                                 key\n                                                                                 value\n                                                                                 left\n                                                                                 newRight)\n                                                                    Remove -> (Remove,\n                                                                               bubble\n                                                                                 clr\n                                                                                 key\n                                                                                 value\n                                                                                 left\n                                                                                 newRight)\n    (flag,updatedDict) = up dict\nin case flag of\n     Same -> updatedDict\n     Insert -> ensureBlackRoot updatedDict\n     Remove -> blacken updatedDict"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"dict"},[{"tag":"Span","contents":[{"line":183,"column":3},{"line":220,"column":52},{"doc":"let up = \\dict -> case dict of\n                    RBEmpty LBlack -> case alter Nothing of\n                                        Nothing -> (Same,empty)\n                                        Just v -> (Insert,RBNode Red k v empty empty)\n                    RBNode clr key value left right -> case compare k key of\n                                                         EQ -> case alter (Just value) of\n                                                                 Nothing -> (Remove,\n                                                                             rem clr left right)\n                                                                 Just newValue -> (Same,\n                                                                                   RBNode\n                                                                                     clr\n                                                                                     key\n                                                                                     newValue\n                                                                                     left\n                                                                                     right)\n                                                         LT -> let (flag,newLeft) = up left\n                                                               in case flag of\n                                                                    Same -> (Same,\n                                                                             RBNode\n                                                                               clr\n                                                                               key\n                                                                               value\n                                                                               newLeft\n                                                                               right)\n                                                                    Insert -> (Insert,\n                                                                               balance\n                                                                                 clr\n                                                                                 key\n                                                                                 value\n                                                                                 newLeft\n                                                                                 right)\n                                                                    Remove -> (Remove,\n                                                                               bubble\n                                                                                 clr\n                                                                                 key\n                                                                                 value\n                                                                                 newLeft\n                                                                                 right)\n                                                         GT -> let (flag,newRight) = up right\n                                                               in case flag of\n                                                                    Same -> (Same,\n                                                                             RBNode\n                                                                               clr\n                                                                               key\n                                                                               value\n                                                                               left\n                                                                               newRight)\n                                                                    Insert -> (Insert,\n                                                                               balance\n                                                                                 clr\n                                                                                 key\n                                                                                 value\n                                                                                 left\n                                                                                 newRight)\n                                                                    Remove -> (Remove,\n                                                                               bubble\n                                                                                 clr\n                                                                                 key\n                                                                                 value\n                                                                                 left\n                                                                                 newRight)\n    (flag,updatedDict) = up dict\nin case flag of\n     Same -> updatedDict\n     Insert -> ensureBlackRoot updatedDict\n     Remove -> blacken updatedDict"}]},{"tag":"Let","contents":[[[{"tag":"Var","contents":"up"},[{"tag":"Span","contents":[{"line":184,"column":11},{"line":212,"column":7},{"doc":"case dict of\n  RBEmpty LBlack -> case alter Nothing of\n                      Nothing -> (Same,empty)\n                      Just v -> (Insert,RBNode Red k v empty empty)\n  RBNode clr key value left right -> case compare k key of\n                                       EQ -> case alter (Just value) of\n                                               Nothing -> (Remove,rem clr left right)\n                                               Just newValue -> (Same,\n                                                                 RBNode clr key newValue left right)\n                                       LT -> let (flag,newLeft) = up left\n                                             in case flag of\n                                                  Same -> (Same,RBNode clr key value newLeft right)\n                                                  Insert -> (Insert,\n                                                             balance clr key value newLeft right)\n                                                  Remove -> (Remove,\n                                                             bubble clr key value newLeft right)\n                                       GT -> let (flag,newRight) = up right\n                                             in case flag of\n                                                  Same -> (Same,RBNode clr key value left newRight)\n                                                  Insert -> (Insert,\n                                                             balance clr key value left newRight)\n                                                  Remove -> (Remove,\n                                                             bubble clr key value left newRight)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"dict"},[{"tag":"Span","contents":[{"line":184,"column":11},{"line":212,"column":7},{"doc":"case dict of\n  RBEmpty LBlack -> case alter Nothing of\n                      Nothing -> (Same,empty)\n                      Just v -> (Insert,RBNode Red k v empty empty)\n  RBNode clr key value left right -> case compare k key of\n                                       EQ -> case alter (Just value) of\n                                               Nothing -> (Remove,rem clr left right)\n                                               Just newValue -> (Same,\n                                                                 RBNode clr key newValue left right)\n                                       LT -> let (flag,newLeft) = up left\n                                             in case flag of\n                                                  Same -> (Same,RBNode clr key value newLeft right)\n                                                  Insert -> (Insert,\n                                                             balance clr key value newLeft right)\n                                                  Remove -> (Remove,\n                                                             bubble clr key value newLeft right)\n                                       GT -> let (flag,newRight) = up right\n                                             in case flag of\n                                                  Same -> (Same,RBNode clr key value left newRight)\n                                                  Insert -> (Insert,\n                                                             balance clr key value left newRight)\n                                                  Remove -> (Remove,\n                                                             bubble clr key value left newRight)"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":184,"column":16},{"line":184,"column":20},{"doc":"dict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"dict"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBEmpty"},[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"LBlack"},[]]}]]},[{"tag":"Span","contents":[{"line":186,"column":17},{"line":190,"column":13},{"doc":"case alter Nothing of\n  Nothing -> (Same,empty)\n  Just v -> (Insert,RBNode Red k v empty empty)"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":186,"column":22},{"line":186,"column":35},{"doc":"alter Nothing"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":186,"column":22},{"line":186,"column":27},{"doc":"alter"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"alter"}}],[{"tag":"Span","contents":[{"line":186,"column":28},{"line":186,"column":35},{"doc":"Nothing"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Maybe"]},"name":"Nothing"}}]]}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Maybe"]},"name":"Nothing"},[]]},[{"tag":"Span","contents":[{"line":187,"column":31},{"line":187,"column":42},{"doc":"(Same,empty)"}]},{"tag":"Data","contents":["_Tuple2",[[{"tag":"Span","contents":[{"line":187,"column":31},{"line":187,"column":35},{"doc":"Same"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Same"}}],[{"tag":"Span","contents":[{"line":187,"column":37},{"line":187,"column":42},{"doc":"empty"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"empty"}}]]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Maybe"]},"name":"Just"},[{"tag":"Var","contents":"v"}]]},[{"tag":"Span","contents":[{"line":188,"column":31},{"line":188,"column":65},{"doc":"(Insert,RBNode Red k v empty empty)"}]},{"tag":"Data","contents":["_Tuple2",[[{"tag":"Span","contents":[{"line":188,"column":31},{"line":188,"column":37},{"doc":"Insert"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Insert"}}],[{"tag":"Span","contents":[{"line":188,"column":39},{"line":188,"column":65},{"doc":"RBNode Red k v empty empty"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":188,"column":39},{"line":188,"column":59},{"doc":"RBNode Red k v empty"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":188,"column":39},{"line":188,"column":53},{"doc":"RBNode Red k v"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":188,"column":39},{"line":188,"column":51},{"doc":"RBNode Red k"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":188,"column":39},{"line":188,"column":49},{"doc":"RBNode Red"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":188,"column":39},{"line":188,"column":45},{"doc":"RBNode"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBNode"}}],[{"tag":"Span","contents":[{"line":188,"column":46},{"line":188,"column":49},{"doc":"Red"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Red"}}]]}],[{"tag":"Span","contents":[{"line":188,"column":50},{"line":188,"column":51},{"doc":"k"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"k"}}]]}],[{"tag":"Span","contents":[{"line":188,"column":52},{"line":188,"column":53},{"doc":"v"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"v"}}]]}],[{"tag":"Span","contents":[{"line":188,"column":54},{"line":188,"column":59},{"doc":"empty"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"empty"}}]]}],[{"tag":"Span","contents":[{"line":188,"column":60},{"line":188,"column":65},{"doc":"empty"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"empty"}}]]}]]]}]]]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"RBNode"},[{"tag":"Var","contents":"clr"},{"tag":"Var","contents":"key"},{"tag":"Var","contents":"value"},{"tag":"Var","contents":"left"},{"tag":"Var","contents":"right"}]]},[{"tag":"Span","contents":[{"line":191,"column":17},{"line":212,"column":7},{"doc":"case compare k key of\n  EQ -> case alter (Just value) of\n          Nothing -> (Remove,rem clr left right)\n          Just newValue -> (Same,RBNode clr key newValue left right)\n  LT -> let (flag,newLeft) = up left\n        in case flag of\n             Same -> (Same,RBNode clr key value newLeft right)\n             Insert -> (Insert,balance clr key value newLeft right)\n             Remove -> (Remove,bubble clr key value newLeft right)\n  GT -> let (flag,newRight) = up right\n        in case flag of\n             Same -> (Same,RBNode clr key value left newRight)\n             Insert -> (Insert,balance clr key value left newRight)\n             Remove -> (Remove,bubble clr key value left newRight)"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":191,"column":22},{"line":191,"column":35},{"doc":"compare k key"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":191,"column":22},{"line":191,"column":31},{"doc":"compare k"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":191,"column":22},{"line":191,"column":29},{"doc":"compare"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Basics"]},"name":"compare"}}],[{"tag":"Span","contents":[{"line":191,"column":30},{"line":191,"column":31},{"doc":"k"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"k"}}]]}],[{"tag":"Span","contents":[{"line":191,"column":32},{"line":191,"column":35},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}]]}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Basics"]},"name":"EQ"},[]]},[{"tag":"Span","contents":[{"line":193,"column":21},{"line":198,"column":19},{"doc":"case alter (Just value) of\n  Nothing -> (Remove,rem clr left right)\n  Just newValue -> (Same,RBNode clr key newValue left right)"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":193,"column":26},{"line":193,"column":43},{"doc":"alter (Just value)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":193,"column":26},{"line":193,"column":31},{"doc":"alter"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"alter"}}],[{"tag":"Span","contents":[{"line":193,"column":33},{"line":193,"column":43},{"doc":"Just value"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":193,"column":33},{"line":193,"column":37},{"doc":"Just"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Maybe"]},"name":"Just"}}],[{"tag":"Span","contents":[{"line":193,"column":38},{"line":193,"column":43},{"doc":"value"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"value"}}]]}]]}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Maybe"]},"name":"Nothing"},[]]},[{"tag":"Span","contents":[{"line":194,"column":35},{"line":194,"column":61},{"doc":"(Remove,rem clr left right)"}]},{"tag":"Data","contents":["_Tuple2",[[{"tag":"Span","contents":[{"line":194,"column":35},{"line":194,"column":41},{"doc":"Remove"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Remove"}}],[{"tag":"Span","contents":[{"line":194,"column":43},{"line":194,"column":61},{"doc":"rem clr left right"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":194,"column":43},{"line":194,"column":55},{"doc":"rem clr left"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":194,"column":43},{"line":194,"column":50},{"doc":"rem clr"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":194,"column":43},{"line":194,"column":46},{"doc":"rem"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"rem"}}],[{"tag":"Span","contents":[{"line":194,"column":47},{"line":194,"column":50},{"doc":"clr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"clr"}}]]}],[{"tag":"Span","contents":[{"line":194,"column":51},{"line":194,"column":55},{"doc":"left"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"left"}}]]}],[{"tag":"Span","contents":[{"line":194,"column":56},{"line":194,"column":61},{"doc":"right"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"right"}}]]}]]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Maybe"]},"name":"Just"},[{"tag":"Var","contents":"newValue"}]]},[{"tag":"Span","contents":[{"line":196,"column":28},{"line":196,"column":68},{"doc":"(Same,RBNode clr key newValue left right)"}]},{"tag":"Data","contents":["_Tuple2",[[{"tag":"Span","contents":[{"line":196,"column":28},{"line":196,"column":32},{"doc":"Same"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Same"}}],[{"tag":"Span","contents":[{"line":196,"column":34},{"line":196,"column":68},{"doc":"RBNode clr key newValue left right"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":196,"column":34},{"line":196,"column":62},{"doc":"RBNode clr key newValue left"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":196,"column":34},{"line":196,"column":57},{"doc":"RBNode clr key newValue"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":196,"column":34},{"line":196,"column":48},{"doc":"RBNode clr key"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":196,"column":34},{"line":196,"column":44},{"doc":"RBNode clr"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":196,"column":34},{"line":196,"column":40},{"doc":"RBNode"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBNode"}}],[{"tag":"Span","contents":[{"line":196,"column":41},{"line":196,"column":44},{"doc":"clr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"clr"}}]]}],[{"tag":"Span","contents":[{"line":196,"column":45},{"line":196,"column":48},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}]]}],[{"tag":"Span","contents":[{"line":196,"column":49},{"line":196,"column":57},{"doc":"newValue"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"newValue"}}]]}],[{"tag":"Span","contents":[{"line":196,"column":58},{"line":196,"column":62},{"doc":"left"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"left"}}]]}],[{"tag":"Span","contents":[{"line":196,"column":63},{"line":196,"column":68},{"doc":"right"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"right"}}]]}]]]}]]]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Basics"]},"name":"LT"},[]]},[{"tag":"Span","contents":[{"line":199,"column":21},{"line":205,"column":19},{"doc":"let (flag,newLeft) = up left\nin case flag of\n     Same -> (Same,RBNode clr key value newLeft right)\n     Insert -> (Insert,balance clr key value newLeft right)\n     Remove -> (Remove,bubble clr key value newLeft right)"}]},{"tag":"Let","contents":[[[{"tag":"Data","contents":[{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"},[{"tag":"Var","contents":"flag"},{"tag":"Var","contents":"newLeft"}]]},[{"tag":"Span","contents":[{"line":199,"column":43},{"line":199,"column":50},{"doc":"up left"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":199,"column":43},{"line":199,"column":45},{"doc":"up"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"up"}}],[{"tag":"Span","contents":[{"line":199,"column":46},{"line":199,"column":50},{"doc":"left"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"left"}}]]}],null]],[{"tag":"Span","contents":[{"line":200,"column":21},{"line":205,"column":19},{"doc":"case flag of\n  Same -> (Same,RBNode clr key value newLeft right)\n  Insert -> (Insert,balance clr key value newLeft right)\n  Remove -> (Remove,bubble clr key value newLeft right)"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":200,"column":26},{"line":200,"column":30},{"doc":"flag"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"flag"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Same"},[]]},[{"tag":"Span","contents":[{"line":201,"column":34},{"line":201,"column":74},{"doc":"(Same,RBNode clr key value newLeft right)"}]},{"tag":"Data","contents":["_Tuple2",[[{"tag":"Span","contents":[{"line":201,"column":34},{"line":201,"column":38},{"doc":"Same"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Same"}}],[{"tag":"Span","contents":[{"line":201,"column":40},{"line":201,"column":74},{"doc":"RBNode clr key value newLeft right"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":201,"column":40},{"line":201,"column":68},{"doc":"RBNode clr key value newLeft"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":201,"column":40},{"line":201,"column":60},{"doc":"RBNode clr key value"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":201,"column":40},{"line":201,"column":54},{"doc":"RBNode clr key"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":201,"column":40},{"line":201,"column":50},{"doc":"RBNode clr"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":201,"column":40},{"line":201,"column":46},{"doc":"RBNode"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBNode"}}],[{"tag":"Span","contents":[{"line":201,"column":47},{"line":201,"column":50},{"doc":"clr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"clr"}}]]}],[{"tag":"Span","contents":[{"line":201,"column":51},{"line":201,"column":54},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}]]}],[{"tag":"Span","contents":[{"line":201,"column":55},{"line":201,"column":60},{"doc":"value"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"value"}}]]}],[{"tag":"Span","contents":[{"line":201,"column":61},{"line":201,"column":68},{"doc":"newLeft"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"newLeft"}}]]}],[{"tag":"Span","contents":[{"line":201,"column":69},{"line":201,"column":74},{"doc":"right"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"right"}}]]}]]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Insert"},[]]},[{"tag":"Span","contents":[{"line":202,"column":34},{"line":202,"column":77},{"doc":"(Insert,balance clr key value newLeft right)"}]},{"tag":"Data","contents":["_Tuple2",[[{"tag":"Span","contents":[{"line":202,"column":34},{"line":202,"column":40},{"doc":"Insert"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Insert"}}],[{"tag":"Span","contents":[{"line":202,"column":42},{"line":202,"column":77},{"doc":"balance clr key value newLeft right"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":202,"column":42},{"line":202,"column":71},{"doc":"balance clr key value newLeft"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":202,"column":42},{"line":202,"column":63},{"doc":"balance clr key value"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":202,"column":42},{"line":202,"column":57},{"doc":"balance clr key"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":202,"column":42},{"line":202,"column":53},{"doc":"balance clr"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":202,"column":42},{"line":202,"column":49},{"doc":"balance"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"balance"}}],[{"tag":"Span","contents":[{"line":202,"column":50},{"line":202,"column":53},{"doc":"clr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"clr"}}]]}],[{"tag":"Span","contents":[{"line":202,"column":54},{"line":202,"column":57},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}]]}],[{"tag":"Span","contents":[{"line":202,"column":58},{"line":202,"column":63},{"doc":"value"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"value"}}]]}],[{"tag":"Span","contents":[{"line":202,"column":64},{"line":202,"column":71},{"doc":"newLeft"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"newLeft"}}]]}],[{"tag":"Span","contents":[{"line":202,"column":72},{"line":202,"column":77},{"doc":"right"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"right"}}]]}]]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Remove"},[]]},[{"tag":"Span","contents":[{"line":203,"column":34},{"line":203,"column":76},{"doc":"(Remove,bubble clr key value newLeft right)"}]},{"tag":"Data","contents":["_Tuple2",[[{"tag":"Span","contents":[{"line":203,"column":34},{"line":203,"column":40},{"doc":"Remove"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Remove"}}],[{"tag":"Span","contents":[{"line":203,"column":42},{"line":203,"column":76},{"doc":"bubble clr key value newLeft right"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":203,"column":42},{"line":203,"column":70},{"doc":"bubble clr key value newLeft"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":203,"column":42},{"line":203,"column":62},{"doc":"bubble clr key value"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":203,"column":42},{"line":203,"column":56},{"doc":"bubble clr key"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":203,"column":42},{"line":203,"column":52},{"doc":"bubble clr"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":203,"column":42},{"line":203,"column":48},{"doc":"bubble"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"bubble"}}],[{"tag":"Span","contents":[{"line":203,"column":49},{"line":203,"column":52},{"doc":"clr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"clr"}}]]}],[{"tag":"Span","contents":[{"line":203,"column":53},{"line":203,"column":56},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}]]}],[{"tag":"Span","contents":[{"line":203,"column":57},{"line":203,"column":62},{"doc":"value"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"value"}}]]}],[{"tag":"Span","contents":[{"line":203,"column":63},{"line":203,"column":70},{"doc":"newLeft"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"newLeft"}}]]}],[{"tag":"Span","contents":[{"line":203,"column":71},{"line":203,"column":76},{"doc":"right"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"right"}}]]}]]]}]]]]}]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Basics"]},"name":"GT"},[]]},[{"tag":"Span","contents":[{"line":206,"column":21},{"line":212,"column":7},{"doc":"let (flag,newRight) = up right\nin case flag of\n     Same -> (Same,RBNode clr key value left newRight)\n     Insert -> (Insert,balance clr key value left newRight)\n     Remove -> (Remove,bubble clr key value left newRight)"}]},{"tag":"Let","contents":[[[{"tag":"Data","contents":[{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"},[{"tag":"Var","contents":"flag"},{"tag":"Var","contents":"newRight"}]]},[{"tag":"Span","contents":[{"line":206,"column":44},{"line":206,"column":52},{"doc":"up right"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":206,"column":44},{"line":206,"column":46},{"doc":"up"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"up"}}],[{"tag":"Span","contents":[{"line":206,"column":47},{"line":206,"column":52},{"doc":"right"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"right"}}]]}],null]],[{"tag":"Span","contents":[{"line":207,"column":21},{"line":212,"column":7},{"doc":"case flag of\n  Same -> (Same,RBNode clr key value left newRight)\n  Insert -> (Insert,balance clr key value left newRight)\n  Remove -> (Remove,bubble clr key value left newRight)"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":207,"column":26},{"line":207,"column":30},{"doc":"flag"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"flag"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Same"},[]]},[{"tag":"Span","contents":[{"line":208,"column":34},{"line":208,"column":74},{"doc":"(Same,RBNode clr key value left newRight)"}]},{"tag":"Data","contents":["_Tuple2",[[{"tag":"Span","contents":[{"line":208,"column":34},{"line":208,"column":38},{"doc":"Same"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Same"}}],[{"tag":"Span","contents":[{"line":208,"column":40},{"line":208,"column":74},{"doc":"RBNode clr key value left newRight"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":208,"column":40},{"line":208,"column":65},{"doc":"RBNode clr key value left"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":208,"column":40},{"line":208,"column":60},{"doc":"RBNode clr key value"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":208,"column":40},{"line":208,"column":54},{"doc":"RBNode clr key"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":208,"column":40},{"line":208,"column":50},{"doc":"RBNode clr"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":208,"column":40},{"line":208,"column":46},{"doc":"RBNode"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBNode"}}],[{"tag":"Span","contents":[{"line":208,"column":47},{"line":208,"column":50},{"doc":"clr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"clr"}}]]}],[{"tag":"Span","contents":[{"line":208,"column":51},{"line":208,"column":54},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}]]}],[{"tag":"Span","contents":[{"line":208,"column":55},{"line":208,"column":60},{"doc":"value"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"value"}}]]}],[{"tag":"Span","contents":[{"line":208,"column":61},{"line":208,"column":65},{"doc":"left"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"left"}}]]}],[{"tag":"Span","contents":[{"line":208,"column":66},{"line":208,"column":74},{"doc":"newRight"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"newRight"}}]]}]]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Insert"},[]]},[{"tag":"Span","contents":[{"line":209,"column":34},{"line":209,"column":77},{"doc":"(Insert,balance clr key value left newRight)"}]},{"tag":"Data","contents":["_Tuple2",[[{"tag":"Span","contents":[{"line":209,"column":34},{"line":209,"column":40},{"doc":"Insert"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Insert"}}],[{"tag":"Span","contents":[{"line":209,"column":42},{"line":209,"column":77},{"doc":"balance clr key value left newRight"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":209,"column":42},{"line":209,"column":68},{"doc":"balance clr key value left"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":209,"column":42},{"line":209,"column":63},{"doc":"balance clr key value"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":209,"column":42},{"line":209,"column":57},{"doc":"balance clr key"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":209,"column":42},{"line":209,"column":53},{"doc":"balance clr"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":209,"column":42},{"line":209,"column":49},{"doc":"balance"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"balance"}}],[{"tag":"Span","contents":[{"line":209,"column":50},{"line":209,"column":53},{"doc":"clr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"clr"}}]]}],[{"tag":"Span","contents":[{"line":209,"column":54},{"line":209,"column":57},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}]]}],[{"tag":"Span","contents":[{"line":209,"column":58},{"line":209,"column":63},{"doc":"value"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"value"}}]]}],[{"tag":"Span","contents":[{"line":209,"column":64},{"line":209,"column":68},{"doc":"left"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"left"}}]]}],[{"tag":"Span","contents":[{"line":209,"column":69},{"line":209,"column":77},{"doc":"newRight"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"newRight"}}]]}]]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Remove"},[]]},[{"tag":"Span","contents":[{"line":210,"column":34},{"line":210,"column":76},{"doc":"(Remove,bubble clr key value left newRight)"}]},{"tag":"Data","contents":["_Tuple2",[[{"tag":"Span","contents":[{"line":210,"column":34},{"line":210,"column":40},{"doc":"Remove"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"Remove"}}],[{"tag":"Span","contents":[{"line":210,"column":42},{"line":210,"column":76},{"doc":"bubble clr key value left newRight"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":210,"column":42},{"line":210,"column":67},{"doc":"bubble clr key value left"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":210,"column":42},{"line":210,"column":62},{"doc":"bubble clr key value"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":210,"column":42},{"line":210,"column":56},{"doc":"bubble clr key"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":210,"column":42},{"line":210,"column":52},{"doc":"bubble clr"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":210,"column":42},{"line":210,"column":48},{"doc":"bubble"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"bubble"}}],[{"tag":"Span","contents":[{"line":210,"column":49},{"line":210,"column":52},{"doc":"clr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"clr"}}]]}],[{"tag":"Span","contents":[{"line":210,"column":53},{"line":210,"column":56},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}]]}],[{"tag":"Span","contents":[{"line":210,"column":57},{"line":210,"column":62},{"doc":"value"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"value"}}]]}],[{"tag":"Span","contents":[{"line":210,"column":63},{"line":210,"column":67},{"doc":"left"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"left"}}]]}],[{"tag":"Span","contents":[{"line":210,"column":68},{"line":210,"column":76},{"doc":"newRight"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"newRight"}}]]}]]]}]]]]}]]}]]]]}]]]]}]]}],null]],[{"tag":"Span","contents":[{"line":183,"column":3},{"line":220,"column":52},{"doc":"let up = \\dict -> case dict of\n                    RBEmpty LBlack -> case alter Nothing of\n                                        Nothing -> (Same,empty)\n                                        Just v -> (Insert,RBNode Red k v empty empty)\n                    RBNode clr key value left right -> case compare k key of\n                                                         EQ -> case alter (Just value) of\n                                                                 Nothing -> (Remove,\n                                                                             rem clr left right)\n                                                                 Just newValue -> (Same,\n                                                                                   RBNode\n                                                                                     clr\n                                                                                     key\n                                                                                     newValue\n                                                                                     left\n                                                                                     right)\n                                                         LT -> let (flag,newLeft) = up left\n                                                               in case flag of\n                                                                    Same -> (Same,\n                                                                             RBNode\n                                                                               clr\n                                                                               key\n                                                                               value\n                                                                               newLeft\n                                                                               right)\n                                                                    Insert -> (Insert,\n                                                                               balance\n                                                                                 clr\n                                                                                 key\n                                                                                 value\n                                                                                 newLeft\n                                                                                 right)\n                                                                    Remove -> (Remove,\n                                                                               bubble\n                                                                                 clr\n                                                                                 key\n                                                                                 value\n                                                                                 newLeft\n                                                                                 right)\n                                                         GT -> let (flag,newRight) = up right\n                                                               in case flag of\n                                                                    Same -> (Same,\n                                                                             RBNode\n                                                                               clr\n                                                                               key\n                                                                               value\n                                                                               left\n                                                                               newRight)\n                                                                    Insert -> (Insert,\n                                                                               balance\n                                                                                 clr\n                                                                                 key\n                                                                                 value\n                                                                                 left\n                                                                                 newRight)\n                                                                    Remove -> (Remove,\n                                                                               bubble\n                                                                                 clr\n                                                                                 key\n                                                                                 value\n                                                                                 left\n                                                                                 newRight)\n    (flag,updatedDict) = up dict\nin case flag of\n     Same -> updatedDict\n     Insert -> ensureBlackRoot updatedDict\n     Remove -> blacken updatedDict"}]},{"tag":"Let","contents":[[[{"tag":"Data","contents":[{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"},[{"tag":"Var","contents":"flag"},{"tag":"Var","contents":"updatedDict"}]]},[{"tag":"Span","contents":[{"line":212,"column":29},{"line":212,"column":36},{"doc":"up dict"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":212,"column":29},{"line":212,"column":31},{"doc":"up"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"up"}}],[{"tag":"Span","contents":[{"line":212,"column":32},{"line":212,"column":36},{"doc":"dict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"dict"}}]]}],null]],[{"tag":"Span","contents":[{"line":214,"column":7},{"line":220,"column":52},{"doc":"case flag of\n  Same -> updatedDict\n  Insert -> ensureBlackRoot updatedDict\n  Remove -> blacken updatedDict"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":214,"column":12},{"line":214,"column":16},{"doc":"flag"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"flag"}}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Same"},[]]},[{"tag":"Span","contents":[{"line":215,"column":19},{"line":215,"column":30},{"doc":"updatedDict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"updatedDict"}}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Insert"},[]]},[{"tag":"Span","contents":[{"line":216,"column":19},{"line":216,"column":46},{"doc":"ensureBlackRoot updatedDict"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":216,"column":19},{"line":216,"column":34},{"doc":"ensureBlackRoot"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"ensureBlackRoot"}}],[{"tag":"Span","contents":[{"line":216,"column":35},{"line":216,"column":46},{"doc":"updatedDict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"updatedDict"}}]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Dict"]},"name":"Remove"},[]]},[{"tag":"Span","contents":[{"line":217,"column":19},{"line":217,"column":38},{"doc":"blacken updatedDict"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":217,"column":19},{"line":217,"column":26},{"doc":"blacken"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"blacken"}}],[{"tag":"Span","contents":[{"line":217,"column":27},{"line":217,"column":38},{"doc":"updatedDict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"updatedDict"}}]]}]]]]}]]}]]}]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"Var","contents":"comparable"},{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Maybe"]},"name":"Maybe"}},[{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Maybe"]},"name":"Maybe"}},[{"tag":"Var","contents":"v"}]]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]}]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"insert"},[{"tag":"Span","contents":[{"line":161,"column":5},{"line":161,"column":42},{"doc":"update key (always (Just value)) dict"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"key"},[{"tag":"Span","contents":[{"line":161,"column":5},{"line":161,"column":42},{"doc":"update key (always (Just value)) dict"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"value"},[{"tag":"Span","contents":[{"line":161,"column":5},{"line":161,"column":42},{"doc":"update key (always (Just value)) dict"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"dict"},[{"tag":"Span","contents":[{"line":161,"column":5},{"line":161,"column":42},{"doc":"update key (always (Just value)) dict"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":161,"column":5},{"line":161,"column":35},{"doc":"update key (always (Just value))"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":161,"column":5},{"line":161,"column":15},{"doc":"update key"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":161,"column":5},{"line":161,"column":11},{"doc":"update"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"update"}}],[{"tag":"Span","contents":[{"line":161,"column":12},{"line":161,"column":15},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}]]}],[{"tag":"Span","contents":[{"line":161,"column":17},{"line":161,"column":35},{"doc":"always (Just value)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":161,"column":17},{"line":161,"column":23},{"doc":"always"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Basics"]},"name":"always"}}],[{"tag":"Span","contents":[{"line":161,"column":25},{"line":161,"column":35},{"doc":"Just value"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":161,"column":25},{"line":161,"column":29},{"doc":"Just"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Maybe"]},"name":"Just"}}],[{"tag":"Span","contents":[{"line":161,"column":30},{"line":161,"column":35},{"doc":"value"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"value"}}]]}]]}]]}],[{"tag":"Span","contents":[{"line":161,"column":38},{"line":161,"column":42},{"doc":"dict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"dict"}}]]}]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"Var","contents":"comparable"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"v"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]}]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"singleton"},[{"tag":"Span","contents":[{"line":223,"column":5},{"line":223,"column":37},{"doc":"insert key value (RBEmpty LBlack)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"key"},[{"tag":"Span","contents":[{"line":223,"column":5},{"line":223,"column":37},{"doc":"insert key value (RBEmpty LBlack)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"value"},[{"tag":"Span","contents":[{"line":223,"column":5},{"line":223,"column":37},{"doc":"insert key value (RBEmpty LBlack)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":223,"column":5},{"line":223,"column":21},{"doc":"insert key value"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":223,"column":5},{"line":223,"column":15},{"doc":"insert key"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":223,"column":5},{"line":223,"column":11},{"doc":"insert"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"insert"}}],[{"tag":"Span","contents":[{"line":223,"column":12},{"line":223,"column":15},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}]]}],[{"tag":"Span","contents":[{"line":223,"column":16},{"line":223,"column":21},{"doc":"value"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"value"}}]]}],[{"tag":"Span","contents":[{"line":223,"column":23},{"line":223,"column":37},{"doc":"RBEmpty LBlack"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":223,"column":23},{"line":223,"column":30},{"doc":"RBEmpty"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"RBEmpty"}}],[{"tag":"Span","contents":[{"line":223,"column":31},{"line":223,"column":37},{"doc":"LBlack"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"LBlack"}}]]}]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"Var","contents":"comparable"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"v"},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"union"},[{"tag":"Span","contents":[{"line":420,"column":5},{"line":420,"column":23},{"doc":"foldl insert t2 t1"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"t1"},[{"tag":"Span","contents":[{"line":420,"column":5},{"line":420,"column":23},{"doc":"foldl insert t2 t1"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"t2"},[{"tag":"Span","contents":[{"line":420,"column":5},{"line":420,"column":23},{"doc":"foldl insert t2 t1"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":420,"column":5},{"line":420,"column":20},{"doc":"foldl insert t2"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":420,"column":5},{"line":420,"column":17},{"doc":"foldl insert"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":420,"column":5},{"line":420,"column":10},{"doc":"foldl"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"foldl"}}],[{"tag":"Span","contents":[{"line":420,"column":11},{"line":420,"column":17},{"doc":"insert"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"insert"}}]]}],[{"tag":"Span","contents":[{"line":420,"column":18},{"line":420,"column":20},{"doc":"t2"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"t2"}}]]}],[{"tag":"Span","contents":[{"line":420,"column":21},{"line":420,"column":23},{"doc":"t1"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"t1"}}]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"fromList"},[{"tag":"Span","contents":[{"line":458,"column":5},{"line":458,"column":73},{"doc":"List.foldl\n  (\\(key,value) dict -> insert key value dict) empty assocs"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"assocs"},[{"tag":"Span","contents":[{"line":458,"column":5},{"line":458,"column":73},{"doc":"List.foldl\n  (\\(key,value) dict -> insert key value dict) empty assocs"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":458,"column":5},{"line":458,"column":66},{"doc":"List.foldl (\\(key,value) dict -> insert key value dict) empty"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":458,"column":5},{"line":458,"column":59},{"doc":"List.foldl (\\(key,value) dict -> insert key value dict)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":458,"column":5},{"line":458,"column":15},{"doc":"List.foldl"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["List"]},"name":"foldl"}}],[{"tag":"Span","contents":[{"line":458,"column":38},{"line":458,"column":59},{"doc":"insert key value dict"}]},{"tag":"Lambda","contents":[{"tag":"Data","contents":[{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"},[{"tag":"Var","contents":"key"},{"tag":"Var","contents":"value"}]]},[{"tag":"Span","contents":[{"line":458,"column":38},{"line":458,"column":59},{"doc":"insert key value dict"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"dict"},[{"tag":"Span","contents":[{"line":458,"column":38},{"line":458,"column":59},{"doc":"insert key value dict"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":458,"column":38},{"line":458,"column":54},{"doc":"insert key value"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":458,"column":38},{"line":458,"column":48},{"doc":"insert key"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":458,"column":38},{"line":458,"column":44},{"doc":"insert"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"insert"}}],[{"tag":"Span","contents":[{"line":458,"column":45},{"line":458,"column":48},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}]]}],[{"tag":"Span","contents":[{"line":458,"column":49},{"line":458,"column":54},{"doc":"value"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"value"}}]]}],[{"tag":"Span","contents":[{"line":458,"column":55},{"line":458,"column":59},{"doc":"dict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"dict"}}]]}]]}]]}]]}],[{"tag":"Span","contents":[{"line":458,"column":61},{"line":458,"column":66},{"doc":"empty"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"empty"}}]]}],[{"tag":"Span","contents":[{"line":458,"column":67},{"line":458,"column":73},{"doc":"assocs"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"assocs"}}]]}]]}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"filter"},[{"tag":"Span","contents":[{"line":464,"column":5},{"line":469,"column":35},{"doc":"let add = \\key value dict -> if | predicate key value ->\n                                    insert key value dict\n                                | True -> dict\nin foldl add empty dictionary"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"predicate"},[{"tag":"Span","contents":[{"line":464,"column":5},{"line":469,"column":35},{"doc":"let add = \\key value dict -> if | predicate key value ->\n                                    insert key value dict\n                                | True -> dict\nin foldl add empty dictionary"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"dictionary"},[{"tag":"Span","contents":[{"line":464,"column":5},{"line":469,"column":35},{"doc":"let add = \\key value dict -> if | predicate key value ->\n                                    insert key value dict\n                                | True -> dict\nin foldl add empty dictionary"}]},{"tag":"Let","contents":[[[{"tag":"Var","contents":"add"},[{"tag":"Span","contents":[{"line":465,"column":13},{"line":467,"column":26},{"doc":"if | predicate key value -> insert key value dict\n   | True -> dict"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"key"},[{"tag":"Span","contents":[{"line":465,"column":13},{"line":467,"column":26},{"doc":"if | predicate key value -> insert key value dict\n   | True -> dict"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"value"},[{"tag":"Span","contents":[{"line":465,"column":13},{"line":467,"column":26},{"doc":"if | predicate key value -> insert key value dict\n   | True -> dict"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"dict"},[{"tag":"Span","contents":[{"line":465,"column":13},{"line":467,"column":26},{"doc":"if | predicate key value -> insert key value dict\n   | True -> dict"}]},{"tag":"MultiIf","contents":[[[{"tag":"Span","contents":[{"line":465,"column":16},{"line":465,"column":35},{"doc":"predicate key value"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":465,"column":16},{"line":465,"column":29},{"doc":"predicate key"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":465,"column":16},{"line":465,"column":25},{"doc":"predicate"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"predicate"}}],[{"tag":"Span","contents":[{"line":465,"column":26},{"line":465,"column":29},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}]]}],[{"tag":"Span","contents":[{"line":465,"column":30},{"line":465,"column":35},{"doc":"value"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"value"}}]]}],[{"tag":"Span","contents":[{"line":466,"column":22},{"line":466,"column":43},{"doc":"insert key value dict"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":466,"column":22},{"line":466,"column":38},{"doc":"insert key value"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":466,"column":22},{"line":466,"column":32},{"doc":"insert key"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":466,"column":22},{"line":466,"column":28},{"doc":"insert"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"insert"}}],[{"tag":"Span","contents":[{"line":466,"column":29},{"line":466,"column":32},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}]]}],[{"tag":"Span","contents":[{"line":466,"column":33},{"line":466,"column":38},{"doc":"value"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"value"}}]]}],[{"tag":"Span","contents":[{"line":466,"column":39},{"line":466,"column":43},{"doc":"dict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"dict"}}]]}]],[[{"tag":"Span","contents":[{"line":467,"column":22},{"line":467,"column":26},{"doc":"dict"}]},{"tag":"Literal","contents":{"tag":"Boolean","contents":true}}],[{"tag":"Span","contents":[{"line":467,"column":22},{"line":467,"column":26},{"doc":"dict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"dict"}}]]]}]]}]]}]]}],null]],[{"tag":"Span","contents":[{"line":469,"column":9},{"line":469,"column":35},{"doc":"foldl add empty dictionary"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":469,"column":9},{"line":469,"column":24},{"doc":"foldl add empty"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":469,"column":9},{"line":469,"column":18},{"doc":"foldl add"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":469,"column":9},{"line":469,"column":14},{"doc":"foldl"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"foldl"}}],[{"tag":"Span","contents":[{"line":469,"column":15},{"line":469,"column":18},{"doc":"add"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"add"}}]]}],[{"tag":"Span","contents":[{"line":469,"column":19},{"line":469,"column":24},{"doc":"empty"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"empty"}}]]}],[{"tag":"Span","contents":[{"line":469,"column":25},{"line":469,"column":35},{"doc":"dictionary"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"dictionary"}}]]}]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"comparable"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"v"},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"intersect"},[{"tag":"Span","contents":[{"line":427,"column":5},{"line":427,"column":38},{"doc":"filter (\\k _ -> k `member` t2) t1"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"t1"},[{"tag":"Span","contents":[{"line":427,"column":5},{"line":427,"column":38},{"doc":"filter (\\k _ -> k `member` t2) t1"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"t2"},[{"tag":"Span","contents":[{"line":427,"column":5},{"line":427,"column":38},{"doc":"filter (\\k _ -> k `member` t2) t1"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":427,"column":5},{"line":427,"column":34},{"doc":"filter (\\k _ -> k `member` t2)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":427,"column":5},{"line":427,"column":11},{"doc":"filter"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"filter"}}],[{"tag":"Span","contents":[{"line":427,"column":21},{"line":427,"column":34},{"doc":"k `member` t2"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"k"},[{"tag":"Span","contents":[{"line":427,"column":21},{"line":427,"column":34},{"doc":"k `member` t2"}]},{"tag":"Lambda","contents":[{"tag":"Anything","contents":[]},[{"tag":"Span","contents":[{"line":427,"column":21},{"line":427,"column":34},{"doc":"k `member` t2"}]},{"tag":"Binop","contents":[{"home":{"tag":"Local","contents":[]},"name":"member"},[{"tag":"Span","contents":[{"line":427,"column":21},{"line":427,"column":22},{"doc":"k"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"k"}}],[{"tag":"Span","contents":[{"line":427,"column":32},{"line":427,"column":34},{"doc":"t2"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"t2"}}]]}]]}]]}]]}],[{"tag":"Span","contents":[{"line":427,"column":36},{"line":427,"column":38},{"doc":"t1"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"t1"}}]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"partition"},[{"tag":"Span","contents":[{"line":478,"column":5},{"line":483,"column":38},{"doc":"let add = \\key value (t1,t2) -> if | predicate key value ->\n                                       (insert key value t1,t2)\n                                   | True -> (t1,insert key value t2)\nin foldl add (empty,empty) dict"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"predicate"},[{"tag":"Span","contents":[{"line":478,"column":5},{"line":483,"column":38},{"doc":"let add = \\key value (t1,t2) -> if | predicate key value ->\n                                       (insert key value t1,t2)\n                                   | True -> (t1,insert key value t2)\nin foldl add (empty,empty) dict"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"dict"},[{"tag":"Span","contents":[{"line":478,"column":5},{"line":483,"column":38},{"doc":"let add = \\key value (t1,t2) -> if | predicate key value ->\n                                       (insert key value t1,t2)\n                                   | True -> (t1,insert key value t2)\nin foldl add (empty,empty) dict"}]},{"tag":"Let","contents":[[[{"tag":"Var","contents":"add"},[{"tag":"Span","contents":[{"line":479,"column":13},{"line":481,"column":47},{"doc":"if | predicate key value -> (insert key value t1,t2)\n   | True -> (t1,insert key value t2)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"key"},[{"tag":"Span","contents":[{"line":479,"column":13},{"line":481,"column":47},{"doc":"if | predicate key value -> (insert key value t1,t2)\n   | True -> (t1,insert key value t2)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"value"},[{"tag":"Span","contents":[{"line":479,"column":13},{"line":481,"column":47},{"doc":"if | predicate key value -> (insert key value t1,t2)\n   | True -> (t1,insert key value t2)"}]},{"tag":"Lambda","contents":[{"tag":"Data","contents":[{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"},[{"tag":"Var","contents":"t1"},{"tag":"Var","contents":"t2"}]]},[{"tag":"Span","contents":[{"line":479,"column":13},{"line":481,"column":47},{"doc":"if | predicate key value -> (insert key value t1,t2)\n   | True -> (t1,insert key value t2)"}]},{"tag":"MultiIf","contents":[[[{"tag":"Span","contents":[{"line":479,"column":16},{"line":479,"column":35},{"doc":"predicate key value"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":479,"column":16},{"line":479,"column":29},{"doc":"predicate key"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":479,"column":16},{"line":479,"column":25},{"doc":"predicate"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"predicate"}}],[{"tag":"Span","contents":[{"line":479,"column":26},{"line":479,"column":29},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}]]}],[{"tag":"Span","contents":[{"line":479,"column":30},{"line":479,"column":35},{"doc":"value"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"value"}}]]}],[{"tag":"Span","contents":[{"line":480,"column":23},{"line":480,"column":46},{"doc":"(insert key value t1,t2)"}]},{"tag":"Data","contents":["_Tuple2",[[{"tag":"Span","contents":[{"line":480,"column":23},{"line":480,"column":42},{"doc":"insert key value t1"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":480,"column":23},{"line":480,"column":39},{"doc":"insert key value"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":480,"column":23},{"line":480,"column":33},{"doc":"insert key"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":480,"column":23},{"line":480,"column":29},{"doc":"insert"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"insert"}}],[{"tag":"Span","contents":[{"line":480,"column":30},{"line":480,"column":33},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}]]}],[{"tag":"Span","contents":[{"line":480,"column":34},{"line":480,"column":39},{"doc":"value"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"value"}}]]}],[{"tag":"Span","contents":[{"line":480,"column":40},{"line":480,"column":42},{"doc":"t1"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"t1"}}]]}],[{"tag":"Span","contents":[{"line":480,"column":44},{"line":480,"column":46},{"doc":"t2"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"t2"}}]]]}]],[[{"tag":"Span","contents":[{"line":481,"column":23},{"line":481,"column":46},{"doc":"(t1,insert key value t2)"}]},{"tag":"Literal","contents":{"tag":"Boolean","contents":true}}],[{"tag":"Span","contents":[{"line":481,"column":23},{"line":481,"column":46},{"doc":"(t1,insert key value t2)"}]},{"tag":"Data","contents":["_Tuple2",[[{"tag":"Span","contents":[{"line":481,"column":23},{"line":481,"column":25},{"doc":"t1"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"t1"}}],[{"tag":"Span","contents":[{"line":481,"column":27},{"line":481,"column":46},{"doc":"insert key value t2"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":481,"column":27},{"line":481,"column":43},{"doc":"insert key value"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":481,"column":27},{"line":481,"column":37},{"doc":"insert key"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":481,"column":27},{"line":481,"column":33},{"doc":"insert"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"insert"}}],[{"tag":"Span","contents":[{"line":481,"column":34},{"line":481,"column":37},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}]]}],[{"tag":"Span","contents":[{"line":481,"column":38},{"line":481,"column":43},{"doc":"value"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"value"}}]]}],[{"tag":"Span","contents":[{"line":481,"column":44},{"line":481,"column":46},{"doc":"t2"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"t2"}}]]}]]]}]]]}]]}]]}]]}],null]],[{"tag":"Span","contents":[{"line":483,"column":9},{"line":483,"column":38},{"doc":"foldl add (empty,empty) dict"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":483,"column":9},{"line":483,"column":32},{"doc":"foldl add (empty,empty)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":483,"column":9},{"line":483,"column":18},{"doc":"foldl add"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":483,"column":9},{"line":483,"column":14},{"doc":"foldl"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"foldl"}}],[{"tag":"Span","contents":[{"line":483,"column":15},{"line":483,"column":18},{"doc":"add"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"add"}}]]}],[{"tag":"Span","contents":[{"line":483,"column":20},{"line":483,"column":32},{"doc":"(empty,empty)"}]},{"tag":"Data","contents":["_Tuple2",[[{"tag":"Span","contents":[{"line":483,"column":20},{"line":483,"column":25},{"doc":"empty"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"empty"}}],[{"tag":"Span","contents":[{"line":483,"column":27},{"line":483,"column":32},{"doc":"empty"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"empty"}}]]]}]]}],[{"tag":"Span","contents":[{"line":483,"column":34},{"line":483,"column":38},{"doc":"dict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"dict"}}]]}]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"comparable"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"v"},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"}},[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]]}]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"remove"},[{"tag":"Span","contents":[{"line":168,"column":5},{"line":168,"column":37},{"doc":"update key (always Nothing) dict"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"key"},[{"tag":"Span","contents":[{"line":168,"column":5},{"line":168,"column":37},{"doc":"update key (always Nothing) dict"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"dict"},[{"tag":"Span","contents":[{"line":168,"column":5},{"line":168,"column":37},{"doc":"update key (always Nothing) dict"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":168,"column":5},{"line":168,"column":31},{"doc":"update key (always Nothing)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":168,"column":5},{"line":168,"column":15},{"doc":"update key"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":168,"column":5},{"line":168,"column":11},{"doc":"update"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"update"}}],[{"tag":"Span","contents":[{"line":168,"column":12},{"line":168,"column":15},{"doc":"key"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"key"}}]]}],[{"tag":"Span","contents":[{"line":168,"column":17},{"line":168,"column":31},{"doc":"always Nothing"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":168,"column":17},{"line":168,"column":23},{"doc":"always"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Basics"]},"name":"always"}}],[{"tag":"Span","contents":[{"line":168,"column":24},{"line":168,"column":31},{"doc":"Nothing"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Maybe"]},"name":"Nothing"}}]]}]]}],[{"tag":"Span","contents":[{"line":168,"column":33},{"line":168,"column":37},{"doc":"dict"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"dict"}}]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"Var","contents":"comparable"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]}]}]],[{"tag":"None","contents":{"doc":"let Red : Dict.NColor\n    Red = Red\n    Black : Dict.NColor\n    Black = Black\n    BBlack : Dict.NColor\n    BBlack = BBlack\n    NBlack : Dict.NColor\n    NBlack = NBlack\n    showNColor : Dict.NColor -> String\n    showNColor = \\c -> case c of\n                         Dict.Red -> \"Red\"\n                         Dict.Black -> \"Black\"\n                         Dict.BBlack -> \"BBlack\"\n                         Dict.NBlack -> \"NBlack\"\n    LBlack : Dict.LeafColor\n    LBlack = LBlack\n    LBBlack : Dict.LeafColor\n    LBBlack = LBBlack\n    showLColor : Dict.LeafColor -> String\n    showLColor = \\color -> case color of\n                             Dict.LBlack -> \"LBlack\"\n                             Dict.LBBlack -> \"LBBlack\"\n    RBNode : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    RBNode = \\a b c d e -> RBNode a b c d e\n    RBEmpty : Dict.LeafColor -> Dict.Dict k v\n    RBEmpty = \\a -> RBEmpty a\n    empty : Dict.Dict comparable v\n    empty = RBEmpty LBlack\n    min : Dict.Dict k v -> (k, v)\n    min = \\dict -> case dict of\n                     Dict.RBNode _ key value (Dict.RBEmpty Dict.LBlack) _ -> (key,value)\n                     Dict.RBNode _ _ _ left _ -> min left\n                     Dict.RBEmpty Dict.LBlack -> Native.Debug.crash\n                                                   \"(min Empty) is not defined\"\n    max : Dict.Dict k v -> (k, v)\n    max = \\dict -> case dict of\n                     Dict.RBNode _ key value _ (Dict.RBEmpty _) -> (key,value)\n                     Dict.RBNode _ _ _ _ right -> max right\n                     Dict.RBEmpty _ -> Native.Debug.crash \"(max Empty) is not defined\"\n    get : comparable -> Dict.Dict comparable v -> Maybe.Maybe v\n    get = \\targetKey dict -> case dict of\n                               Dict.RBEmpty Dict.LBlack -> Maybe.Nothing\n                               Dict.RBNode _ key value left right -> case Basics.compare\n                                                                            targetKey key\n                                                                     of\n                                                                       Basics.LT -> get\n                                                                                      targetKey left\n                                                                       Basics.EQ -> Maybe.Just value\n                                                                       Basics.GT -> get\n                                                                                      targetKey\n                                                                                      right\n    member : comparable -> Dict.Dict comparable v -> Bool\n    member = \\key dict -> case get key dict of\n                            Maybe.Just _ -> True\n                            Maybe.Nothing -> False\n    ensureBlackRoot : Dict.Dict k v -> Dict.Dict k v\n    ensureBlackRoot = \\dict -> case dict of\n                                 Dict.RBNode Dict.Red key value left right -> RBNode\n                                                                                Black\n                                                                                key\n                                                                                value\n                                                                                left\n                                                                                right\n                                 Dict.RBNode Dict.Black _ _ _ _ -> dict\n                                 Dict.RBEmpty Dict.LBlack -> dict\n    insert : comparable\n             -> v -> Dict.Dict comparable v -> Dict.Dict comparable v\n    insert = \\key value dict -> update\n                                  key (Basics.always (Maybe.Just value)) dict\n    remove : comparable\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    remove = \\key dict -> update key (Basics.always Maybe.Nothing) dict\n    Insert : Dict.Flag\n    Insert = Insert\n    Remove : Dict.Flag\n    Remove = Remove\n    Same : Dict.Flag\n    Same = Same\n    showFlag : Dict.Flag -> String\n    showFlag = \\f -> case f of\n                       Dict.Insert -> \"Insert\"\n                       Dict.Remove -> \"Remove\"\n                       Dict.Same -> \"Same\"\n    update : comparable\n             -> (Maybe.Maybe v -> Maybe.Maybe v)\n             -> Dict.Dict comparable v\n             -> Dict.Dict comparable v\n    update = \\k alter dict -> let up = \\dict -> case dict of\n                                                  Dict.RBEmpty Dict.LBlack -> case alter\n                                                                                     Maybe.Nothing\n                                                                              of\n                                                                                Maybe.Nothing -> (Same,\n                                                                                                  empty)\n                                                                                Maybe.Just v -> (Insert,\n                                                                                                 RBNode\n                                                                                                   Red\n                                                                                                   k\n                                                                                                   v\n                                                                                                   empty\n                                                                                                   empty)\n                                                  Dict.RBNode clr key value left right -> case Basics.compare\n                                                                                                 k\n                                                                                                 key\n                                                                                          of\n                                                                                            Basics.EQ -> case alter\n                                                                                                                (Maybe.Just\n                                                                                                                   value)\n                                                                                                         of\n                                                                                                           Maybe.Nothing -> (Remove,\n                                                                                                                             rem\n                                                                                                                               clr\n                                                                                                                               left\n                                                                                                                               right)\n                                                                                                           Maybe.Just newValue -> (Same,\n                                                                                                                                   RBNode\n                                                                                                                                     clr\n                                                                                                                                     key\n                                                                                                                                     newValue\n                                                                                                                                     left\n                                                                                                                                     right)\n                                                                                            Basics.LT -> let (flag,\n                                                                                                              newLeft) = up\n                                                                                                                           left\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              newLeft\n                                                                                                                              right)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                newLeft\n                                                                                                                                right)\n                                                                                            Basics.GT -> let (flag,\n                                                                                                              newRight) = up\n                                                                                                                            right\n                                                                                                         in case flag\n                                                                                                            of\n                                                                                                              Dict.Same -> (Same,\n                                                                                                                            RBNode\n                                                                                                                              clr\n                                                                                                                              key\n                                                                                                                              value\n                                                                                                                              left\n                                                                                                                              newRight)\n                                                                                                              Dict.Insert -> (Insert,\n                                                                                                                              balance\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                                                                                              Dict.Remove -> (Remove,\n                                                                                                                              bubble\n                                                                                                                                clr\n                                                                                                                                key\n                                                                                                                                value\n                                                                                                                                left\n                                                                                                                                newRight)\n                                  (flag,updatedDict) = up dict\n                              in case flag of\n                                   Dict.Same -> updatedDict\n                                   Dict.Insert -> ensureBlackRoot updatedDict\n                                   Dict.Remove -> blacken updatedDict\n    singleton : comparable -> v -> Dict.Dict comparable v\n    singleton = \\key value -> insert key value (RBEmpty LBlack)\n    isBBlack : Dict.Dict k v -> Bool\n    isBBlack = \\dict -> case dict of\n                          Dict.RBNode Dict.BBlack _ _ _ _ -> True\n                          Dict.RBEmpty Dict.LBBlack -> True\n                          _ -> False\n    moreBlack : Dict.NColor -> Dict.NColor\n    moreBlack = \\color -> case color of\n                            Dict.Black -> BBlack\n                            Dict.Red -> Black\n                            Dict.NBlack -> Red\n                            Dict.BBlack -> Native.Debug.crash\n                                             \"Can't make a double black node more black!\"\n    lessBlack : Dict.NColor -> Dict.NColor\n    lessBlack = \\color -> case color of\n                            Dict.BBlack -> Black\n                            Dict.Black -> Red\n                            Dict.Red -> NBlack\n                            Dict.NBlack -> Native.Debug.crash\n                                             \"Can't make a negative black node less black!\"\n    lessBlackTree : Dict.Dict k v -> Dict.Dict k v\n    lessBlackTree = \\dict -> case dict of\n                               Dict.RBNode c k v l r -> RBNode (lessBlack c) k v l r\n                               Dict.RBEmpty Dict.LBBlack -> RBEmpty LBlack\n    reportRemBug : String -> Dict.NColor -> String -> String -> a\n    reportRemBug = \\msg c lgot rgot -> Native.Debug.crash\n                                         `Basics.<|` (String.concat\n                                                        [\"Internal red-black tree invariant violated, expected \",\n                                                         msg,\n                                                         \" and got \",\n                                                         showNColor c,\n                                                         \"/\",\n                                                         lgot,\n                                                         \"/\",\n                                                         rgot,\n                                                         \"\\nPlease report this bug to <https://github.com/elm-lang/Elm/issues>\"])\n    rem : Dict.NColor\n          -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    rem = \\c l r -> case (l,r) of\n                      (Dict.RBEmpty _,Dict.RBEmpty _) -> case c of\n                                                           Dict.Red -> RBEmpty LBlack\n                                                           Dict.Black -> RBEmpty LBBlack\n                      (Dict.RBEmpty cl,Dict.RBNode cr k' v' l' r') -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.LBlack,\n                                                                         Dict.Red) -> RBNode\n                                                                                        Black\n                                                                                        k'\n                                                                                        v'\n                                                                                        l'\n                                                                                        r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/LBlack/Red\"\n                                                                               c\n                                                                               (showLColor cl)\n                                                                               (showNColor cr)\n                      (Dict.RBNode cl k' v' l' r',Dict.RBEmpty cr) -> case (c,cl,cr) of\n                                                                        (Dict.Black,\n                                                                         Dict.Red,\n                                                                         Dict.LBlack) -> RBNode\n                                                                                           Black\n                                                                                           k'\n                                                                                           v'\n                                                                                           l'\n                                                                                           r'\n                                                                        _ -> reportRemBug\n                                                                               \"Black/Red/LBlack\"\n                                                                               c\n                                                                               (showNColor cl)\n                                                                               (showLColor cr)\n                      (Dict.RBNode cl kl vl ll rl,\n                       Dict.RBNode cr kr vr lr rr) -> let l = RBNode cl kl vl ll rl\n                                                          r = RBNode cr kr vr lr rr\n                                                          (k,v) = max l\n                                                          l' = remove_max cl kl vl ll rl\n                                                      in bubble c k v l' r\n    bubble : Dict.NColor\n             -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    bubble = \\c k v l r -> if | (isBBlack l)\n                                  `Basics.||` (isBBlack r) ->\n                                  balance (moreBlack c) k v (lessBlackTree l) (lessBlackTree r)\n                              | True -> RBNode c k v l r\n    remove_max : Dict.NColor\n                 -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    remove_max = \\c k v l r -> case r of\n                                 Dict.RBEmpty _ -> rem c l r\n                                 Dict.RBNode cr kr vr lr rr -> bubble\n                                                                 c k v l (remove_max cr kr vr lr rr)\n    balance : Dict.NColor\n              -> k -> v -> Dict.Dict k v -> Dict.Dict k v -> Dict.Dict k v\n    balance = \\c k v l r -> balance_node (RBNode c k v l r)\n    blackish : Dict.Dict k v -> Bool\n    blackish = \\t -> case t of\n                       Dict.RBNode c _ _ _ _ -> (c `Basics.==` Black)\n                                                  `Basics.||` (c `Basics.==` BBlack)\n                       Dict.RBEmpty _ -> True\n    balance_node : Dict.Dict k v -> Dict.Dict k v\n    balance_node = \\t -> let assemble = \\col\n                                         xk\n                                         xv\n                                         yk\n                                         yv\n                                         zk\n                                         zv\n                                         a\n                                         b\n                                         c\n                                         d -> RBNode\n                                                (lessBlack col)\n                                                yk\n                                                yv\n                                                (RBNode Black xk xv a b)\n                                                (RBNode Black zk zv c d)\n                         in if | blackish t ->\n                                   case t of\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red yk yv (Dict.RBNode Dict.Red xk xv a b) c) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col zk zv (Dict.RBNode Dict.Red xk xv a (Dict.RBNode Dict.Red yk yv b c)) d -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red zk zv (Dict.RBNode Dict.Red yk yv b c) d) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode col xk xv a (Dict.RBNode Dict.Red yk yv b (Dict.RBNode Dict.Red zk zv c d)) -> assemble\n                                                                                                                                  col\n                                                                                                                                  xk\n                                                                                                                                  xv\n                                                                                                                                  yk\n                                                                                                                                  yv\n                                                                                                                                  zk\n                                                                                                                                  zv\n                                                                                                                                  a\n                                                                                                                                  b\n                                                                                                                                  c\n                                                                                                                                  d\n                                     Dict.RBNode Dict.BBlack xk xv a (Dict.RBNode Dict.NBlack zk zv (Dict.RBNode Dict.Black yk yv b c) d) -> case d\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      a\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         d))\n                                                                                                                                               _ -> t\n                                     Dict.RBNode Dict.BBlack zk zv (Dict.RBNode Dict.NBlack xk xv a (Dict.RBNode Dict.Black yk yv b c)) d -> case a\n                                                                                                                                             of\n                                                                                                                                               Dict.RBNode Dict.Black _ _ _ _ -> RBNode\n                                                                                                                                                                                   Black\n                                                                                                                                                                                   yk\n                                                                                                                                                                                   yv\n                                                                                                                                                                                   (balance\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      xk\n                                                                                                                                                                                      xv\n                                                                                                                                                                                      (redden\n                                                                                                                                                                                         a)\n                                                                                                                                                                                      b)\n                                                                                                                                                                                   (RBNode\n                                                                                                                                                                                      Black\n                                                                                                                                                                                      zk\n                                                                                                                                                                                      zv\n                                                                                                                                                                                      c\n                                                                                                                                                                                      d)\n                                                                                                                                               _ -> t\n                                     _ -> t\n                               | True -> t\n    blacken : Dict.Dict k v -> Dict.Dict k v\n    blacken = \\t -> case t of\n                      Dict.RBEmpty _ -> RBEmpty LBlack\n                      Dict.RBNode _ k v l r -> RBNode Black k v l r\n    redden : Dict.Dict k v -> Dict.Dict k v\n    redden = \\t -> case t of\n                     Dict.RBEmpty _ -> Native.Debug.crash \"can't make a Leaf red\"\n                     Dict.RBNode _ k v l r -> RBNode Red k v l r\n    map : (comparable -> a -> b)\n          -> Dict.Dict comparable a -> Dict.Dict comparable b\n    map = \\f dict -> case dict of\n                       Dict.RBEmpty Dict.LBlack -> RBEmpty LBlack\n                       Dict.RBNode clr key value left right -> RBNode\n                                                                 clr\n                                                                 key\n                                                                 (f key value)\n                                                                 (map f left)\n                                                                 (map f right)\n    foldl : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldl = \\f acc dict -> case dict of\n                             Dict.RBEmpty Dict.LBlack -> acc\n                             Dict.RBNode _ key value left right -> foldl\n                                                                     f\n                                                                     (f key\n                                                                        value\n                                                                        (foldl f acc left))\n                                                                     right\n    foldr : (comparable -> v -> b -> b)\n            -> b -> Dict.Dict comparable v -> b\n    foldr = \\f acc t -> case t of\n                          Dict.RBEmpty Dict.LBlack -> acc\n                          Dict.RBNode _ key value left right -> foldr\n                                                                  f\n                                                                  (f key value (foldr f acc right))\n                                                                  left\n    union : Dict.Dict comparable v\n            -> Dict.Dict comparable v -> Dict.Dict comparable v\n    union = \\t1 t2 -> foldl insert t2 t1\n    intersect : Dict.Dict comparable v\n                -> Dict.Dict comparable v -> Dict.Dict comparable v\n    intersect = \\t1 t2 -> filter (\\k _ -> k `member` t2) t1\n    diff : Dict.Dict comparable v\n           -> Dict.Dict comparable v -> Dict.Dict comparable v\n    diff = \\t1 t2 -> foldl (\\k v t -> remove k t) t1 t2\n    keys : Dict.Dict comparable v -> List comparable\n    keys = \\dict -> foldr\n                      (\\key value keyList -> key `List.::` keyList) [] dict\n    values : Dict.Dict comparable v -> List v\n    values = \\dict -> foldr\n                        (\\key value valueList -> value `List.::` valueList) [] dict\n    toList : Dict.Dict comparable v -> List (comparable, v)\n    toList = \\dict -> foldr\n                        (\\key value list -> (key,value) `List.::` list) [] dict\n    fromList : List (comparable, v) -> Dict.Dict comparable v\n    fromList = \\assocs -> List.foldl\n                            (\\(key,value) dict -> insert key value dict) empty assocs\n    filter : (comparable -> v -> Bool)\n             -> Dict.Dict comparable v -> Dict.Dict comparable v\n    filter = \\predicate dictionary -> let add = \\key\n                                                 value\n                                                 dict -> if | predicate key value ->\n                                                                insert key value dict\n                                                            | True -> dict\n                                      in foldl add empty dictionary\n    partition : (comparable -> v -> Bool)\n                -> Dict.Dict comparable v\n                -> (Dict.Dict comparable v, Dict.Dict comparable v)\n    partition = \\predicate dict -> let add = \\key\n                                              value\n                                              (t1,t2) -> if | predicate key value ->\n                                                                (insert key value t1,t2)\n                                                            | True -> (t1,insert key value t2)\n                                   in foldl add (empty,empty) dict\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"diff"},[{"tag":"Span","contents":[{"line":434,"column":5},{"line":434,"column":39},{"doc":"foldl (\\k v t -> remove k t) t1 t2"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"t1"},[{"tag":"Span","contents":[{"line":434,"column":5},{"line":434,"column":39},{"doc":"foldl (\\k v t -> remove k t) t1 t2"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"t2"},[{"tag":"Span","contents":[{"line":434,"column":5},{"line":434,"column":39},{"doc":"foldl (\\k v t -> remove k t) t1 t2"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":434,"column":5},{"line":434,"column":36},{"doc":"foldl (\\k v t -> remove k t) t1"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":434,"column":5},{"line":434,"column":32},{"doc":"foldl (\\k v t -> remove k t)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":434,"column":5},{"line":434,"column":10},{"doc":"foldl"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"foldl"}}],[{"tag":"Span","contents":[{"line":434,"column":22},{"line":434,"column":32},{"doc":"remove k t"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"k"},[{"tag":"Span","contents":[{"line":434,"column":22},{"line":434,"column":32},{"doc":"remove k t"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"v"},[{"tag":"Span","contents":[{"line":434,"column":22},{"line":434,"column":32},{"doc":"remove k t"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"t"},[{"tag":"Span","contents":[{"line":434,"column":22},{"line":434,"column":32},{"doc":"remove k t"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":434,"column":22},{"line":434,"column":30},{"doc":"remove k"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":434,"column":22},{"line":434,"column":28},{"doc":"remove"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"remove"}}],[{"tag":"Span","contents":[{"line":434,"column":29},{"line":434,"column":30},{"doc":"k"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"k"}}]]}],[{"tag":"Span","contents":[{"line":434,"column":31},{"line":434,"column":32},{"doc":"t"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"t"}}]]}]]}]]}]]}]]}],[{"tag":"Span","contents":[{"line":434,"column":34},{"line":434,"column":36},{"doc":"t1"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"t1"}}]]}],[{"tag":"Span","contents":[{"line":434,"column":37},{"line":434,"column":39},{"doc":"t2"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"t2"}}]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Dict"]},"name":"Dict"}},[{"tag":"Var","contents":"comparable"},{"tag":"Var","contents":"v"}]]}]}]}]],[{"tag":"None","contents":{"doc":"_save_the_environment!!!"}},{"tag":"Var","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"_save_the_environment!!!"}}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}],"ports":[]},"imports":[[["Basics"],{"tag":"Open","contents":{"_explicits":[],"_open":true}}],[["List"],{"tag":"As","contents":"List"}],[["List"],{"tag":"Open","contents":{"_explicits":[],"_open":true}}],[["Maybe"],{"tag":"Open","contents":{"_explicits":[],"_open":true}}],[["Native","Debug"],{"tag":"As","contents":"Native.Debug"}],[["String"],{"tag":"As","contents":"String"}]],"names":["Dict"],"exports":[{"tag":"Value","contents":"empty"},{"tag":"Value","contents":"singleton"},{"tag":"Value","contents":"insert"},{"tag":"Value","contents":"update"},{"tag":"Value","contents":"get"},{"tag":"Value","contents":"remove"},{"tag":"Value","contents":"member"},{"tag":"Value","contents":"filter"},{"tag":"Value","contents":"partition"},{"tag":"Value","contents":"foldl"},{"tag":"Value","contents":"foldr"},{"tag":"Value","contents":"map"},{"tag":"Value","contents":"union"},{"tag":"Value","contents":"intersect"},{"tag":"Value","contents":"diff"},{"tag":"Value","contents":"keys"},{"tag":"Value","contents":"values"},{"tag":"Value","contents":"toList"},{"tag":"Value","contents":"fromList"},{"tag":"Union","contents":["Dict",{"_explicits":[],"_open":false}]}]}
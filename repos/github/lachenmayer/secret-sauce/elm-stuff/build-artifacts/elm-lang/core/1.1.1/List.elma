{"path":"","body":{"fixities":[["R",5,"::"]],"aliases":{},"datatypes":{},"types":{"filterMap":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Maybe"]},"name":"Maybe"}},[{"tag":"Var","contents":"b"}]]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]}]}]},"length":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Int"}}]},"foldl1":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Var","contents":"a"}]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Var","contents":"a"}]}]},"map3":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"c"},{"tag":"Var","contents":"result"}]}]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"c"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"result"}]]}]}]}]}]},"unzip":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"}},[{"tag":"Var","contents":"a"},{"tag":"Var","contents":"b"}]]}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"}},[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]}]]}]},"::":{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]}]},"concatMap":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]}]}]},"maximum":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"comparable"}]]},{"tag":"Var","contents":"comparable"}]},"head":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Var","contents":"a"}]},"map4":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"c"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"d"},{"tag":"Var","contents":"result"}]}]}]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"c"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"d"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"result"}]]}]}]}]}]}]},"foldr":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Var","contents":"b"}]}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Var","contents":"b"}]}]}]},"scanl":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Var","contents":"b"}]}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]}]}]}]},"minimum":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"comparable"}]]},{"tag":"Var","contents":"comparable"}]},"drop":{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Int"}},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]}]},"all":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]}]},"map5":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"c"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"d"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"e"},{"tag":"Var","contents":"result"}]}]}]}]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"c"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"d"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"e"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"result"}]]}]}]}]}]}]}]},"concat":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]},"map":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Var","contents":"b"}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]}]}]},"isEmpty":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]},"repeat":{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Int"}},{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]}]},"scanl1":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Var","contents":"a"}]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]}]},"foldr1":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Var","contents":"a"}]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Var","contents":"a"}]}]},"partition":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"}},[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]]}]}]},"sort":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"comparable"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"comparable"}]]}]},"foldl":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Var","contents":"b"}]}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Var","contents":"b"}]}]}]},"filter":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]}]},"sortWith":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Basics"]},"name":"Order"}}]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]}]},"member":{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]}]},"tail":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]},"reverse":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]},"product":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"number"}]]},{"tag":"Var","contents":"number"}]},"indexedMap":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Int"}},{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Var","contents":"b"}]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]}]}]},"sum":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"number"}]]},{"tag":"Var","contents":"number"}]},"take":{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Int"}},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]}]},"maybeCons":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Maybe"]},"name":"Maybe"}},[{"tag":"Var","contents":"b"}]]}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]}]}]}]},"append":{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]}]},"any":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]}]},"intersperse":{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]}]},"map2":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Var","contents":"result"}]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"result"}]]}]}]}]},"sortBy":{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Var","contents":"comparable"}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]}]}},"program":[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"sortWith"},[{"tag":"Span","contents":[{"line":384,"column":19},{"line":384,"column":32},{"doc":"Native.List.sortWith"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"sortWith"}}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Basics"]},"name":"Order"}}]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"sortBy"},[{"tag":"Span","contents":[{"line":368,"column":17},{"line":368,"column":28},{"doc":"Native.List.sortBy"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"sortBy"}}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Var","contents":"comparable"}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"sort"},[{"tag":"Span","contents":[{"line":354,"column":15},{"line":354,"column":24},{"doc":"Native.List.sort"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"sort"}}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"comparable"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"comparable"}]]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"repeat"},[{"tag":"Span","contents":[{"line":347,"column":17},{"line":347,"column":28},{"doc":"Native.List.repeat"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"repeat"}}],{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Int"}},{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"drop"},[{"tag":"Span","contents":[{"line":340,"column":15},{"line":340,"column":24},{"doc":"Native.List.drop"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"drop"}}],{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Int"}},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"take"},[{"tag":"Span","contents":[{"line":333,"column":15},{"line":333,"column":24},{"doc":"Native.List.take"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"take"}}],{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Int"}},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"map5"},[{"tag":"Span","contents":[{"line":299,"column":15},{"line":299,"column":24},{"doc":"Native.List.map5"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"map5"}}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"c"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"d"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"e"},{"tag":"Var","contents":"result"}]}]}]}]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"c"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"d"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"e"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"result"}]]}]}]}]}]}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"map4"},[{"tag":"Span","contents":[{"line":296,"column":15},{"line":296,"column":24},{"doc":"Native.List.map4"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"map4"}}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"c"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"d"},{"tag":"Var","contents":"result"}]}]}]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"c"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"d"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"result"}]]}]}]}]}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"map3"},[{"tag":"Span","contents":[{"line":293,"column":15},{"line":293,"column":24},{"doc":"Native.List.map3"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"map3"}}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"c"},{"tag":"Var","contents":"result"}]}]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"c"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"result"}]]}]}]}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"map2"},[{"tag":"Span","contents":[{"line":290,"column":15},{"line":290,"column":24},{"doc":"Native.List.map2"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"map2"}}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Var","contents":"result"}]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"result"}]]}]}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"append"},[{"tag":"Span","contents":[{"line":206,"column":17},{"line":206,"column":28},{"doc":"Native.List.append"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"append"}}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"any"},[{"tag":"Span","contents":[{"line":197,"column":14},{"line":197,"column":22},{"doc":"Native.List.any"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"any"}}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"all"},[{"tag":"Span","contents":[{"line":188,"column":14},{"line":188,"column":22},{"doc":"Native.List.all"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"all"}}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"length"},[{"tag":"Span","contents":[{"line":171,"column":17},{"line":171,"column":28},{"doc":"Native.List.length"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"length"}}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Int"}}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"filter"},[{"tag":"Span","contents":[{"line":148,"column":17},{"line":148,"column":28},{"doc":"Native.List.filter"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"filter"}}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"scanl1"},[{"tag":"Span","contents":[{"line":141,"column":17},{"line":141,"column":28},{"doc":"Native.List.scanl1"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"scanl1"}}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Var","contents":"a"}]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"scanl"},[{"tag":"Span","contents":[{"line":134,"column":16},{"line":134,"column":26},{"doc":"Native.List.scanl"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"scanl"}}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Var","contents":"b"}]}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]}]}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"foldr1"},[{"tag":"Span","contents":[{"line":127,"column":17},{"line":127,"column":28},{"doc":"Native.List.foldr1"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"foldr1"}}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Var","contents":"a"}]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Var","contents":"a"}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"foldl1"},[{"tag":"Span","contents":[{"line":123,"column":17},{"line":123,"column":28},{"doc":"Native.List.foldl1"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"foldl1"}}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Var","contents":"a"}]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Var","contents":"a"}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"maximum"},[{"tag":"Span","contents":[{"line":250,"column":11},{"line":250,"column":21},{"doc":"foldl1 max"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":250,"column":11},{"line":250,"column":17},{"doc":"foldl1"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"foldl1"}}],[{"tag":"Span","contents":[{"line":250,"column":18},{"line":250,"column":21},{"doc":"max"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Basics"]},"name":"max"}}]]}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"comparable"}]]},{"tag":"Var","contents":"comparable"}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"minimum"},[{"tag":"Span","contents":[{"line":258,"column":11},{"line":258,"column":21},{"doc":"foldl1 min"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":258,"column":11},{"line":258,"column":17},{"doc":"foldl1"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"foldl1"}}],[{"tag":"Span","contents":[{"line":258,"column":18},{"line":258,"column":21},{"doc":"min"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Basics"]},"name":"min"}}]]}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"comparable"}]]},{"tag":"Var","contents":"comparable"}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"foldr"},[{"tag":"Span","contents":[{"line":119,"column":16},{"line":119,"column":26},{"doc":"Native.List.foldr"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"foldr"}}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Var","contents":"b"}]}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Var","contents":"b"}]}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"concat"},[{"tag":"Span","contents":[{"line":215,"column":5},{"line":215,"column":26},{"doc":"foldr append [] lists"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"lists"},[{"tag":"Span","contents":[{"line":215,"column":5},{"line":215,"column":26},{"doc":"foldr append [] lists"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":215,"column":5},{"line":215,"column":20},{"doc":"foldr append []"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":215,"column":5},{"line":215,"column":17},{"doc":"foldr append"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":215,"column":5},{"line":215,"column":10},{"doc":"foldr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"foldr"}}],[{"tag":"Span","contents":[{"line":215,"column":11},{"line":215,"column":17},{"doc":"append"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"append"}}]]}],[{"tag":"Span","contents":[{"line":215,"column":18},{"line":215,"column":20},{"doc":"[]"}]},{"tag":"ExplicitList","contents":[]}]]}],[{"tag":"Span","contents":[{"line":215,"column":21},{"line":215,"column":26},{"doc":"lists"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"lists"}}]]}]]}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"foldl"},[{"tag":"Span","contents":[{"line":112,"column":16},{"line":112,"column":26},{"doc":"Native.List.foldl"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"foldl"}}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Var","contents":"b"}]}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"b"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Var","contents":"b"}]}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"sum"},[{"tag":"Span","contents":[{"line":233,"column":5},{"line":233,"column":24},{"doc":"foldl (\\x y -> x + y) 0 numbers"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"numbers"},[{"tag":"Span","contents":[{"line":233,"column":5},{"line":233,"column":24},{"doc":"foldl (\\x y -> x + y) 0 numbers"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":233,"column":5},{"line":233,"column":16},{"doc":"foldl (\\x y -> x + y) 0"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":233,"column":5},{"line":233,"column":13},{"doc":"foldl (\\x y -> x + y)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":233,"column":5},{"line":233,"column":10},{"doc":"foldl"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"foldl"}}],[{"tag":"Span","contents":[{"line":233,"column":12},{"line":233,"column":13},{"doc":"\\x y -> x + y"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"x"},[{"tag":"Span","contents":[{"line":233,"column":12},{"line":233,"column":13},{"doc":"\\y -> x + y"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"y"},[{"tag":"Span","contents":[{"line":233,"column":12},{"line":233,"column":13},{"doc":"x + y"}]},{"tag":"Binop","contents":[{"home":{"tag":"Module","contents":["Basics"]},"name":"+"},[{"tag":"Span","contents":[{"line":233,"column":12},{"line":233,"column":13},{"doc":"x"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"x"}}],[{"tag":"Span","contents":[{"line":233,"column":12},{"line":233,"column":13},{"doc":"y"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"y"}}]]}]]}]]}]]}],[{"tag":"Span","contents":[{"line":233,"column":15},{"line":233,"column":16},{"doc":"0"}]},{"tag":"Literal","contents":{"tag":"IntNum","contents":0}}]]}],[{"tag":"Span","contents":[{"line":233,"column":17},{"line":233,"column":24},{"doc":"numbers"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"numbers"}}]]}]]}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"number"}]]},{"tag":"Var","contents":"number"}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"product"},[{"tag":"Span","contents":[{"line":242,"column":5},{"line":242,"column":24},{"doc":"foldl (\\x y -> x * y) 1 numbers"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"numbers"},[{"tag":"Span","contents":[{"line":242,"column":5},{"line":242,"column":24},{"doc":"foldl (\\x y -> x * y) 1 numbers"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":242,"column":5},{"line":242,"column":16},{"doc":"foldl (\\x y -> x * y) 1"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":242,"column":5},{"line":242,"column":13},{"doc":"foldl (\\x y -> x * y)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":242,"column":5},{"line":242,"column":10},{"doc":"foldl"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"foldl"}}],[{"tag":"Span","contents":[{"line":242,"column":12},{"line":242,"column":13},{"doc":"\\x y -> x * y"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"x"},[{"tag":"Span","contents":[{"line":242,"column":12},{"line":242,"column":13},{"doc":"\\y -> x * y"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"y"},[{"tag":"Span","contents":[{"line":242,"column":12},{"line":242,"column":13},{"doc":"x * y"}]},{"tag":"Binop","contents":[{"home":{"tag":"Module","contents":["Basics"]},"name":"*"},[{"tag":"Span","contents":[{"line":242,"column":12},{"line":242,"column":13},{"doc":"x"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"x"}}],[{"tag":"Span","contents":[{"line":242,"column":12},{"line":242,"column":13},{"doc":"y"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"y"}}]]}]]}]]}]]}],[{"tag":"Span","contents":[{"line":242,"column":15},{"line":242,"column":16},{"doc":"1"}]},{"tag":"Literal","contents":{"tag":"IntNum","contents":1}}]]}],[{"tag":"Span","contents":[{"line":242,"column":17},{"line":242,"column":24},{"doc":"numbers"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"numbers"}}]]}]]}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"number"}]]},{"tag":"Var","contents":"number"}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"indexedMap"},[{"tag":"Span","contents":[{"line":105,"column":5},{"line":105,"column":37},{"doc":"map2 f [0..(length xs) - 1] xs"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"f"},[{"tag":"Span","contents":[{"line":105,"column":5},{"line":105,"column":37},{"doc":"map2 f [0..(length xs) - 1] xs"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"xs"},[{"tag":"Span","contents":[{"line":105,"column":5},{"line":105,"column":37},{"doc":"map2 f [0..(length xs) - 1] xs"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":105,"column":5},{"line":105,"column":34},{"doc":"map2 f [0..(length xs) - 1]"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":105,"column":5},{"line":105,"column":11},{"doc":"map2 f"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":105,"column":5},{"line":105,"column":9},{"doc":"map2"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"map2"}}],[{"tag":"Span","contents":[{"line":105,"column":10},{"line":105,"column":11},{"doc":"f"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"f"}}]]}],[{"tag":"Span","contents":[{"line":105,"column":12},{"line":105,"column":34},{"doc":"[0..(length xs) - 1]"}]},{"tag":"Range","contents":[[{"tag":"Span","contents":[{"line":105,"column":14},{"line":105,"column":15},{"doc":"0"}]},{"tag":"Literal","contents":{"tag":"IntNum","contents":0}}],[{"tag":"Span","contents":[{"line":105,"column":19},{"line":105,"column":32},{"doc":"(length xs) - 1"}]},{"tag":"Binop","contents":[{"home":{"tag":"Module","contents":["Basics"]},"name":"-"},[{"tag":"Span","contents":[{"line":105,"column":19},{"line":105,"column":28},{"doc":"length xs"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":105,"column":19},{"line":105,"column":25},{"doc":"length"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"length"}}],[{"tag":"Span","contents":[{"line":105,"column":26},{"line":105,"column":28},{"doc":"xs"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"xs"}}]]}],[{"tag":"Span","contents":[{"line":105,"column":31},{"line":105,"column":32},{"doc":"1"}]},{"tag":"Literal","contents":{"tag":"IntNum","contents":1}}]]}]]}]]}],[{"tag":"Span","contents":[{"line":105,"column":35},{"line":105,"column":37},{"doc":"xs"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"xs"}}]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Int"}},{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Var","contents":"b"}]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"map"},[{"tag":"Span","contents":[{"line":96,"column":14},{"line":96,"column":22},{"doc":"Native.List.map"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"map"}}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Var","contents":"b"}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"concatMap"},[{"tag":"Span","contents":[{"line":224,"column":5},{"line":224,"column":23},{"doc":"concat (map f list)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"f"},[{"tag":"Span","contents":[{"line":224,"column":5},{"line":224,"column":23},{"doc":"concat (map f list)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"list"},[{"tag":"Span","contents":[{"line":224,"column":5},{"line":224,"column":23},{"doc":"concat (map f list)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":224,"column":5},{"line":224,"column":11},{"doc":"concat"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"concat"}}],[{"tag":"Span","contents":[{"line":224,"column":13},{"line":224,"column":23},{"doc":"map f list"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":224,"column":13},{"line":224,"column":18},{"doc":"map f"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":224,"column":13},{"line":224,"column":16},{"doc":"map"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"map"}}],[{"tag":"Span","contents":[{"line":224,"column":17},{"line":224,"column":18},{"doc":"f"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"f"}}]]}],[{"tag":"Span","contents":[{"line":224,"column":19},{"line":224,"column":23},{"doc":"list"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"list"}}]]}]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"member"},[{"tag":"Span","contents":[{"line":86,"column":10},{"line":86,"column":21},{"doc":"Native.List.member"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"member"}}],{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"isEmpty"},[{"tag":"Span","contents":[{"line":79,"column":5},{"line":81,"column":18},{"doc":"case xs of\n  [] -> True\n  _ -> False"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"xs"},[{"tag":"Span","contents":[{"line":79,"column":5},{"line":81,"column":18},{"doc":"case xs of\n  [] -> True\n  _ -> False"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":79,"column":10},{"line":79,"column":12},{"doc":"xs"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"xs"}}],[[{"tag":"Data","contents":[{"home":{"tag":"BuiltIn","contents":[]},"name":"[]"},[]]},[{"tag":"Span","contents":[{"line":80,"column":13},{"line":80,"column":17},{"doc":"True"}]},{"tag":"Literal","contents":{"tag":"Boolean","contents":true}}]],[{"tag":"Anything","contents":[]},[{"tag":"Span","contents":[{"line":81,"column":13},{"line":81,"column":18},{"doc":"False"}]},{"tag":"Literal","contents":{"tag":"Boolean","contents":false}}]]]]}]]}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"tail"},[{"tag":"Span","contents":[{"line":70,"column":15},{"line":70,"column":24},{"doc":"Native.List.tail"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"tail"}}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"head"},[{"tag":"Span","contents":[{"line":62,"column":15},{"line":62,"column":24},{"doc":"Native.List.head"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"head"}}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"Var","contents":"a"}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"::"},[{"tag":"Span","contents":[{"line":51,"column":15},{"line":51,"column":24},{"doc":"Native.List.cons"}]},{"tag":"Var","contents":{"home":{"tag":"Module","contents":["Native","List"]},"name":"cons"}}],{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"maybeCons"},[{"tag":"Span","contents":[{"line":162,"column":5},{"line":169,"column":3},{"doc":"case f mx of\n  Just x -> x :: xs\n  Nothing -> xs"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"f"},[{"tag":"Span","contents":[{"line":162,"column":5},{"line":169,"column":3},{"doc":"case f mx of\n  Just x -> x :: xs\n  Nothing -> xs"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"mx"},[{"tag":"Span","contents":[{"line":162,"column":5},{"line":169,"column":3},{"doc":"case f mx of\n  Just x -> x :: xs\n  Nothing -> xs"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"xs"},[{"tag":"Span","contents":[{"line":162,"column":5},{"line":169,"column":3},{"doc":"case f mx of\n  Just x -> x :: xs\n  Nothing -> xs"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":162,"column":10},{"line":162,"column":14},{"doc":"f mx"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":162,"column":10},{"line":162,"column":11},{"doc":"f"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"f"}}],[{"tag":"Span","contents":[{"line":162,"column":12},{"line":162,"column":14},{"doc":"mx"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"mx"}}]]}],[[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Maybe"]},"name":"Just"},[{"tag":"Var","contents":"x"}]]},[{"tag":"Span","contents":[{"line":163,"column":17},{"line":163,"column":24},{"doc":"x :: xs"}]},{"tag":"Binop","contents":[{"home":{"tag":"Local","contents":[]},"name":"::"},[{"tag":"Span","contents":[{"line":163,"column":17},{"line":163,"column":18},{"doc":"x"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"x"}}],[{"tag":"Span","contents":[{"line":163,"column":22},{"line":163,"column":24},{"doc":"xs"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"xs"}}]]}]],[{"tag":"Data","contents":[{"home":{"tag":"Module","contents":["Maybe"]},"name":"Nothing"},[]]},[{"tag":"Span","contents":[{"line":164,"column":18},{"line":164,"column":20},{"doc":"xs"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"xs"}}]]]]}]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Maybe"]},"name":"Maybe"}},[{"tag":"Var","contents":"b"}]]}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]}]}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"filterMap"},[{"tag":"Span","contents":[{"line":158,"column":18},{"line":158,"column":43},{"doc":"foldr (maybeCons f) [] xs"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"f"},[{"tag":"Span","contents":[{"line":158,"column":18},{"line":158,"column":43},{"doc":"foldr (maybeCons f) [] xs"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"xs"},[{"tag":"Span","contents":[{"line":158,"column":18},{"line":158,"column":43},{"doc":"foldr (maybeCons f) [] xs"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":158,"column":18},{"line":158,"column":40},{"doc":"foldr (maybeCons f) []"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":158,"column":18},{"line":158,"column":36},{"doc":"foldr (maybeCons f)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":158,"column":18},{"line":158,"column":23},{"doc":"foldr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"foldr"}}],[{"tag":"Span","contents":[{"line":158,"column":25},{"line":158,"column":36},{"doc":"maybeCons f"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":158,"column":25},{"line":158,"column":34},{"doc":"maybeCons"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"maybeCons"}}],[{"tag":"Span","contents":[{"line":158,"column":35},{"line":158,"column":36},{"doc":"f"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"f"}}]]}]]}],[{"tag":"Span","contents":[{"line":158,"column":38},{"line":158,"column":40},{"doc":"[]"}]},{"tag":"ExplicitList","contents":[]}]]}],[{"tag":"Span","contents":[{"line":158,"column":41},{"line":158,"column":43},{"doc":"xs"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"xs"}}]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"Module","contents":["Maybe"]},"name":"Maybe"}},[{"tag":"Var","contents":"b"}]]}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"reverse"},[{"tag":"Span","contents":[{"line":179,"column":5},{"line":179,"column":18},{"doc":"foldl (\\x y -> x :: y) []"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":179,"column":5},{"line":179,"column":14},{"doc":"foldl (\\x y -> x :: y)"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":179,"column":5},{"line":179,"column":10},{"doc":"foldl"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"foldl"}}],[{"tag":"Span","contents":[{"line":179,"column":12},{"line":179,"column":14},{"doc":"\\x y -> x :: y"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"x"},[{"tag":"Span","contents":[{"line":179,"column":12},{"line":179,"column":14},{"doc":"\\y -> x :: y"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"y"},[{"tag":"Span","contents":[{"line":179,"column":12},{"line":179,"column":14},{"doc":"x :: y"}]},{"tag":"Binop","contents":[{"home":{"tag":"Local","contents":[]},"name":"::"},[{"tag":"Span","contents":[{"line":179,"column":12},{"line":179,"column":14},{"doc":"x"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"x"}}],[{"tag":"Span","contents":[{"line":179,"column":12},{"line":179,"column":14},{"doc":"y"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"y"}}]]}]]}]]}]]}],[{"tag":"Span","contents":[{"line":179,"column":16},{"line":179,"column":18},{"doc":"[]"}]},{"tag":"ExplicitList","contents":[]}]]}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"partition"},[{"tag":"Span","contents":[{"line":270,"column":5},{"line":275,"column":32},{"doc":"let step = \\x (trues,falses) -> if | pred x -> (x :: trues,falses)\n                                   | True -> (trues,x :: falses)\nin foldr step ([],[]) list"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"pred"},[{"tag":"Span","contents":[{"line":270,"column":5},{"line":275,"column":32},{"doc":"let step = \\x (trues,falses) -> if | pred x -> (x :: trues,falses)\n                                   | True -> (trues,x :: falses)\nin foldr step ([],[]) list"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"list"},[{"tag":"Span","contents":[{"line":270,"column":5},{"line":275,"column":32},{"doc":"let step = \\x (trues,falses) -> if | pred x -> (x :: trues,falses)\n                                   | True -> (trues,x :: falses)\nin foldr step ([],[]) list"}]},{"tag":"Let","contents":[[[{"tag":"Var","contents":"step"},[{"tag":"Span","contents":[{"line":271,"column":13},{"line":273,"column":42},{"doc":"if | pred x -> (x :: trues,falses)\n   | True -> (trues,x :: falses)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"x"},[{"tag":"Span","contents":[{"line":271,"column":13},{"line":273,"column":42},{"doc":"if | pred x -> (x :: trues,falses)\n   | True -> (trues,x :: falses)"}]},{"tag":"Lambda","contents":[{"tag":"Data","contents":[{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"},[{"tag":"Var","contents":"trues"},{"tag":"Var","contents":"falses"}]]},[{"tag":"Span","contents":[{"line":271,"column":13},{"line":273,"column":42},{"doc":"if | pred x -> (x :: trues,falses)\n   | True -> (trues,x :: falses)"}]},{"tag":"MultiIf","contents":[[[{"tag":"Span","contents":[{"line":271,"column":16},{"line":271,"column":22},{"doc":"pred x"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":271,"column":16},{"line":271,"column":20},{"doc":"pred"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"pred"}}],[{"tag":"Span","contents":[{"line":271,"column":21},{"line":271,"column":22},{"doc":"x"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"x"}}]]}],[{"tag":"Span","contents":[{"line":272,"column":23},{"line":272,"column":41},{"doc":"(x :: trues,falses)"}]},{"tag":"Data","contents":["_Tuple2",[[{"tag":"Span","contents":[{"line":272,"column":23},{"line":272,"column":33},{"doc":"x :: trues"}]},{"tag":"Binop","contents":[{"home":{"tag":"Local","contents":[]},"name":"::"},[{"tag":"Span","contents":[{"line":272,"column":23},{"line":272,"column":24},{"doc":"x"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"x"}}],[{"tag":"Span","contents":[{"line":272,"column":28},{"line":272,"column":33},{"doc":"trues"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"trues"}}]]}],[{"tag":"Span","contents":[{"line":272,"column":35},{"line":272,"column":41},{"doc":"falses"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"falses"}}]]]}]],[[{"tag":"Span","contents":[{"line":273,"column":23},{"line":273,"column":41},{"doc":"(trues,x :: falses)"}]},{"tag":"Literal","contents":{"tag":"Boolean","contents":true}}],[{"tag":"Span","contents":[{"line":273,"column":23},{"line":273,"column":41},{"doc":"(trues,x :: falses)"}]},{"tag":"Data","contents":["_Tuple2",[[{"tag":"Span","contents":[{"line":273,"column":23},{"line":273,"column":28},{"doc":"trues"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"trues"}}],[{"tag":"Span","contents":[{"line":273,"column":30},{"line":273,"column":41},{"doc":"x :: falses"}]},{"tag":"Binop","contents":[{"home":{"tag":"Local","contents":[]},"name":"::"},[{"tag":"Span","contents":[{"line":273,"column":30},{"line":273,"column":31},{"doc":"x"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"x"}}],[{"tag":"Span","contents":[{"line":273,"column":35},{"line":273,"column":41},{"doc":"falses"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"falses"}}]]}]]]}]]]}]]}]]}],null]],[{"tag":"Span","contents":[{"line":275,"column":9},{"line":275,"column":32},{"doc":"foldr step ([],[]) list"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":275,"column":9},{"line":275,"column":26},{"doc":"foldr step ([],[])"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":275,"column":9},{"line":275,"column":19},{"doc":"foldr step"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":275,"column":9},{"line":275,"column":14},{"doc":"foldr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"foldr"}}],[{"tag":"Span","contents":[{"line":275,"column":15},{"line":275,"column":19},{"doc":"step"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"step"}}]]}],[{"tag":"Span","contents":[{"line":275,"column":21},{"line":275,"column":26},{"doc":"([],[])"}]},{"tag":"Data","contents":["_Tuple2",[[{"tag":"Span","contents":[{"line":275,"column":21},{"line":275,"column":23},{"doc":"[]"}]},{"tag":"ExplicitList","contents":[]}],[{"tag":"Span","contents":[{"line":275,"column":24},{"line":275,"column":26},{"doc":"[]"}]},{"tag":"ExplicitList","contents":[]}]]]}]]}],[{"tag":"Span","contents":[{"line":275,"column":28},{"line":275,"column":32},{"doc":"list"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"list"}}]]}]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"Bool"}}]},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"}},[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]]}]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"unzip"},[{"tag":"Span","contents":[{"line":308,"column":5},{"line":311,"column":34},{"doc":"let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\nin foldr step ([],[]) pairs"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"pairs"},[{"tag":"Span","contents":[{"line":308,"column":5},{"line":311,"column":34},{"doc":"let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\nin foldr step ([],[]) pairs"}]},{"tag":"Let","contents":[[[{"tag":"Var","contents":"step"},[{"tag":"Span","contents":[{"line":309,"column":12},{"line":309,"column":28},{"doc":"(x :: xs,y :: ys)"}]},{"tag":"Lambda","contents":[{"tag":"Data","contents":[{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"},[{"tag":"Var","contents":"x"},{"tag":"Var","contents":"y"}]]},[{"tag":"Span","contents":[{"line":309,"column":12},{"line":309,"column":28},{"doc":"(x :: xs,y :: ys)"}]},{"tag":"Lambda","contents":[{"tag":"Data","contents":[{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"},[{"tag":"Var","contents":"xs"},{"tag":"Var","contents":"ys"}]]},[{"tag":"Span","contents":[{"line":309,"column":12},{"line":309,"column":28},{"doc":"(x :: xs,y :: ys)"}]},{"tag":"Data","contents":["_Tuple2",[[{"tag":"Span","contents":[{"line":309,"column":12},{"line":309,"column":19},{"doc":"x :: xs"}]},{"tag":"Binop","contents":[{"home":{"tag":"Local","contents":[]},"name":"::"},[{"tag":"Span","contents":[{"line":309,"column":12},{"line":309,"column":13},{"doc":"x"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"x"}}],[{"tag":"Span","contents":[{"line":309,"column":17},{"line":309,"column":19},{"doc":"xs"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"xs"}}]]}],[{"tag":"Span","contents":[{"line":309,"column":21},{"line":309,"column":28},{"doc":"y :: ys"}]},{"tag":"Binop","contents":[{"home":{"tag":"Local","contents":[]},"name":"::"},[{"tag":"Span","contents":[{"line":309,"column":21},{"line":309,"column":22},{"doc":"y"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"y"}}],[{"tag":"Span","contents":[{"line":309,"column":26},{"line":309,"column":28},{"doc":"ys"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"ys"}}]]}]]]}]]}]]}],null]],[{"tag":"Span","contents":[{"line":311,"column":9},{"line":311,"column":34},{"doc":"foldr step ([],[]) pairs"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":311,"column":9},{"line":311,"column":27},{"doc":"foldr step ([],[])"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":311,"column":9},{"line":311,"column":19},{"doc":"foldr step"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":311,"column":9},{"line":311,"column":14},{"doc":"foldr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"foldr"}}],[{"tag":"Span","contents":[{"line":311,"column":15},{"line":311,"column":19},{"doc":"step"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"step"}}]]}],[{"tag":"Span","contents":[{"line":311,"column":21},{"line":311,"column":27},{"doc":"([],[])"}]},{"tag":"Data","contents":["_Tuple2",[[{"tag":"Span","contents":[{"line":311,"column":21},{"line":311,"column":23},{"doc":"[]"}]},{"tag":"ExplicitList","contents":[]}],[{"tag":"Span","contents":[{"line":311,"column":25},{"line":311,"column":27},{"doc":"[]"}]},{"tag":"ExplicitList","contents":[]}]]]}]]}],[{"tag":"Span","contents":[{"line":311,"column":29},{"line":311,"column":34},{"doc":"pairs"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"pairs"}}]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"}},[{"tag":"Var","contents":"a"},{"tag":"Var","contents":"b"}]]}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"_Tuple2"}},[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"b"}]]}]]}]}]],[{"tag":"None","contents":{"doc":"let (::) : a -> List a -> List a\n    (::) = Native.List.cons\n    head : List a -> a\n    head = Native.List.head\n    tail : List a -> List a\n    tail = Native.List.tail\n    isEmpty : List a -> Bool\n    isEmpty = \\xs -> case xs of\n                       [] -> True\n                       _ -> False\n    member : a -> List a -> Bool\n    member = Native.List.member\n    map : (a -> b) -> List a -> List b\n    map = Native.List.map\n    indexedMap : (Int -> a -> b) -> List a -> List b\n    indexedMap = \\f xs -> map2 f [0..(length xs) `Basics.-` 1] xs\n    foldl : (a -> b -> b) -> b -> List a -> b\n    foldl = Native.List.foldl\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr = Native.List.foldr\n    foldl1 : (a -> a -> a) -> List a -> a\n    foldl1 = Native.List.foldl1\n    foldr1 : (a -> a -> a) -> List a -> a\n    foldr1 = Native.List.foldr1\n    scanl : (a -> b -> b) -> b -> List a -> List b\n    scanl = Native.List.scanl\n    scanl1 : (a -> a -> a) -> List a -> List a\n    scanl1 = Native.List.scanl1\n    filter : (a -> Bool) -> List a -> List a\n    filter = Native.List.filter\n    filterMap : (a -> Maybe.Maybe b) -> List a -> List b\n    filterMap = \\f xs -> foldr (maybeCons f) [] xs\n    maybeCons : (a -> Maybe.Maybe b) -> a -> List b -> List b\n    maybeCons = \\f mx xs -> case f mx of\n                              Maybe.Just x -> x :: xs\n                              Maybe.Nothing -> xs\n    length : List a -> Int\n    length = Native.List.length\n    reverse : List a -> List a\n    reverse = foldl (\\x y -> x :: y) []\n    all : (a -> Bool) -> List a -> Bool\n    all = Native.List.all\n    any : (a -> Bool) -> List a -> Bool\n    any = Native.List.any\n    append : List a -> List a -> List a\n    append = Native.List.append\n    concat : List (List a) -> List a\n    concat = \\lists -> foldr append [] lists\n    concatMap : (a -> List b) -> List a -> List b\n    concatMap = \\f list -> concat (map f list)\n    sum : List number -> number\n    sum = \\numbers -> foldl (\\x y -> x `Basics.+` y) 0 numbers\n    product : List number -> number\n    product = \\numbers -> foldl (\\x y -> x `Basics.*` y) 1 numbers\n    maximum : List comparable -> comparable\n    maximum = foldl1 Basics.max\n    minimum : List comparable -> comparable\n    minimum = foldl1 Basics.min\n    partition : (a -> Bool) -> List a -> (List a, List a)\n    partition = \\pred list -> let step = \\x (trues,falses) -> if | pred\n                                                                     x ->\n                                                                     (x :: trues,falses)\n                                                                 | True -> (trues,x :: falses)\n                              in foldr step ([],[]) list\n    map2 : (a -> b -> result) -> List a -> List b -> List result\n    map2 = Native.List.map2\n    map3 : (a -> b -> c -> result)\n           -> List a -> List b -> List c -> List result\n    map3 = Native.List.map3\n    map4 : (a -> b -> c -> d -> result)\n           -> List a -> List b -> List c -> List d -> List result\n    map4 = Native.List.map4\n    map5 : (a -> b -> c -> d -> e -> result)\n           -> List a -> List b -> List c -> List d -> List e -> List result\n    map5 = Native.List.map5\n    unzip : List (a, b) -> (List a, List b)\n    unzip = \\pairs -> let step = \\(x,y) (xs,ys) -> (x :: xs,y :: ys)\n                      in foldr step ([],[]) pairs\n    intersperse : a -> List a -> List a\n    intersperse = \\sep xs -> case xs of\n                               [] -> []\n                               hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                                               spersed = foldr step [] tl\n                                           in hd :: spersed\n    take : Int -> List a -> List a\n    take = Native.List.take\n    drop : Int -> List a -> List a\n    drop = Native.List.drop\n    repeat : Int -> a -> List a\n    repeat = Native.List.repeat\n    sort : List comparable -> List comparable\n    sort = Native.List.sort\n    sortBy : (a -> comparable) -> List a -> List a\n    sortBy = Native.List.sortBy\n    sortWith : (a -> a -> Basics.Order) -> List a -> List a\n    sortWith = Native.List.sortWith\nin _save_the_environment!!!"}},{"tag":"Let","contents":[[[{"tag":"Var","contents":"intersperse"},[{"tag":"Span","contents":[{"line":320,"column":5},{"line":331,"column":3},{"doc":"case xs of\n  [] -> []\n  hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                  spersed = foldr step [] tl\n              in hd :: spersed"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"sep"},[{"tag":"Span","contents":[{"line":320,"column":5},{"line":331,"column":3},{"doc":"case xs of\n  [] -> []\n  hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                  spersed = foldr step [] tl\n              in hd :: spersed"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"xs"},[{"tag":"Span","contents":[{"line":320,"column":5},{"line":331,"column":3},{"doc":"case xs of\n  [] -> []\n  hd :: tl -> let step = \\x rest -> sep :: (x :: rest)\n                  spersed = foldr step [] tl\n              in hd :: spersed"}]},{"tag":"Case","contents":[[{"tag":"Span","contents":[{"line":320,"column":10},{"line":320,"column":12},{"doc":"xs"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"xs"}}],[[{"tag":"Data","contents":[{"home":{"tag":"BuiltIn","contents":[]},"name":"[]"},[]]},[{"tag":"Span","contents":[{"line":321,"column":13},{"line":321,"column":15},{"doc":"[]"}]},{"tag":"ExplicitList","contents":[]}]],[{"tag":"Data","contents":[{"home":{"tag":"BuiltIn","contents":[]},"name":"::"},[{"tag":"Var","contents":"hd"},{"tag":"Var","contents":"tl"}]]},[{"tag":"Span","contents":[{"line":323,"column":11},{"line":326,"column":28},{"doc":"let step = \\x rest -> sep :: (x :: rest)\n    spersed = foldr step [] tl\nin hd :: spersed"}]},{"tag":"Let","contents":[[[{"tag":"Var","contents":"step"},[{"tag":"Span","contents":[{"line":323,"column":29},{"line":323,"column":45},{"doc":"sep :: (x :: rest)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"x"},[{"tag":"Span","contents":[{"line":323,"column":29},{"line":323,"column":45},{"doc":"sep :: (x :: rest)"}]},{"tag":"Lambda","contents":[{"tag":"Var","contents":"rest"},[{"tag":"Span","contents":[{"line":323,"column":29},{"line":323,"column":45},{"doc":"sep :: (x :: rest)"}]},{"tag":"Binop","contents":[{"home":{"tag":"Local","contents":[]},"name":"::"},[{"tag":"Span","contents":[{"line":323,"column":29},{"line":323,"column":32},{"doc":"sep"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"sep"}}],[{"tag":"Span","contents":[{"line":323,"column":36},{"line":323,"column":45},{"doc":"x :: rest"}]},{"tag":"Binop","contents":[{"home":{"tag":"Local","contents":[]},"name":"::"},[{"tag":"Span","contents":[{"line":323,"column":36},{"line":323,"column":37},{"doc":"x"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"x"}}],[{"tag":"Span","contents":[{"line":323,"column":41},{"line":323,"column":45},{"doc":"rest"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"rest"}}]]}]]}]]}]]}],null]],[{"tag":"Span","contents":[{"line":323,"column":11},{"line":326,"column":28},{"doc":"let step = \\x rest -> sep :: (x :: rest)\n    spersed = foldr step [] tl\nin hd :: spersed"}]},{"tag":"Let","contents":[[[{"tag":"Var","contents":"spersed"},[{"tag":"Span","contents":[{"line":324,"column":25},{"line":324,"column":41},{"doc":"foldr step [] tl"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":324,"column":25},{"line":324,"column":38},{"doc":"foldr step []"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":324,"column":25},{"line":324,"column":35},{"doc":"foldr step"}]},{"tag":"App","contents":[[{"tag":"Span","contents":[{"line":324,"column":25},{"line":324,"column":30},{"doc":"foldr"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"foldr"}}],[{"tag":"Span","contents":[{"line":324,"column":31},{"line":324,"column":35},{"doc":"step"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"step"}}]]}],[{"tag":"Span","contents":[{"line":324,"column":36},{"line":324,"column":38},{"doc":"[]"}]},{"tag":"ExplicitList","contents":[]}]]}],[{"tag":"Span","contents":[{"line":324,"column":39},{"line":324,"column":41},{"doc":"tl"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"tl"}}]]}],null]],[{"tag":"Span","contents":[{"line":326,"column":15},{"line":326,"column":28},{"doc":"hd :: spersed"}]},{"tag":"Binop","contents":[{"home":{"tag":"Local","contents":[]},"name":"::"},[{"tag":"Span","contents":[{"line":326,"column":15},{"line":326,"column":17},{"doc":"hd"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"hd"}}],[{"tag":"Span","contents":[{"line":326,"column":21},{"line":326,"column":28},{"doc":"spersed"}]},{"tag":"Var","contents":{"home":{"tag":"Local","contents":[]},"name":"spersed"}}]]}]]}]]}]]]]}]]}]]}],{"tag":"Lambda","contents":[{"tag":"Var","contents":"a"},{"tag":"Lambda","contents":[{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]},{"tag":"App","contents":[{"tag":"Type","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"List"}},[{"tag":"Var","contents":"a"}]]}]}]}]],[{"tag":"None","contents":{"doc":"_save_the_environment!!!"}},{"tag":"Var","contents":{"home":{"tag":"BuiltIn","contents":[]},"name":"_save_the_environment!!!"}}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}]]}],"ports":[]},"imports":[[["Basics"],{"tag":"Open","contents":{"_explicits":[],"_open":true}}],[["Maybe"],{"tag":"Open","contents":{"_explicits":[{"tag":"Union","contents":["Maybe",{"_explicits":["Just","Nothing"],"_open":false}]}],"_open":false}}],[["Native","List"],{"tag":"As","contents":"Native.List"}]],"names":["List"],"exports":[{"tag":"Value","contents":"::"},{"tag":"Value","contents":"head"},{"tag":"Value","contents":"tail"},{"tag":"Value","contents":"isEmpty"},{"tag":"Value","contents":"member"},{"tag":"Value","contents":"map"},{"tag":"Value","contents":"indexedMap"},{"tag":"Value","contents":"foldl"},{"tag":"Value","contents":"foldr"},{"tag":"Value","contents":"foldl1"},{"tag":"Value","contents":"foldr1"},{"tag":"Value","contents":"scanl"},{"tag":"Value","contents":"scanl1"},{"tag":"Value","contents":"filter"},{"tag":"Value","contents":"filterMap"},{"tag":"Value","contents":"maybeCons"},{"tag":"Value","contents":"length"},{"tag":"Value","contents":"reverse"},{"tag":"Value","contents":"all"},{"tag":"Value","contents":"any"},{"tag":"Value","contents":"append"},{"tag":"Value","contents":"concat"},{"tag":"Value","contents":"concatMap"},{"tag":"Value","contents":"sum"},{"tag":"Value","contents":"product"},{"tag":"Value","contents":"maximum"},{"tag":"Value","contents":"minimum"},{"tag":"Value","contents":"partition"},{"tag":"Value","contents":"map2"},{"tag":"Value","contents":"map3"},{"tag":"Value","contents":"map4"},{"tag":"Value","contents":"map5"},{"tag":"Value","contents":"unzip"},{"tag":"Value","contents":"intersperse"},{"tag":"Value","contents":"take"},{"tag":"Value","contents":"drop"},{"tag":"Value","contents":"repeat"},{"tag":"Value","contents":"sort"},{"tag":"Value","contents":"sortBy"},{"tag":"Value","contents":"sortWith"}]}